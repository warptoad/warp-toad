{
    "transpiled": true,
    "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
    "name": "ObsidionDeployerFPC",
    "functions": [
        {
            "name": "sync_notes",
            "is_unconstrained": true,
            "custom_attributes": [
                "aztec::macros::functions::utility"
            ],
            "abi": {
                "parameters": [],
                "return_type": null,
                "error_types": {
                    "576755928210959028": {
                        "error_kind": "string",
                        "string": "0 has a square root; you cannot claim it is not square"
                    },
                    "2709101749560550278": {
                        "error_kind": "string",
                        "string": "Cannot serialize point at infinity as bytes."
                    },
                    "2896122431943215824": {
                        "error_kind": "fmtstring",
                        "length": 144,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "2920182694213909827": {
                        "error_kind": "string",
                        "string": "attempt to subtract with overflow"
                    },
                    "3305101268118424981": {
                        "error_kind": "string",
                        "string": "Attempted to delete past the length of a CapsuleArray"
                    },
                    "3367683922240523006": {
                        "error_kind": "fmtstring",
                        "length": 58,
                        "item_types": [
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "5019202896831570965": {
                        "error_kind": "string",
                        "string": "attempt to add with overflow"
                    },
                    "5727012404371710682": {
                        "error_kind": "string",
                        "string": "push out of bounds"
                    },
                    "5870202753060865374": {
                        "error_kind": "fmtstring",
                        "length": 61,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "6336853191198150230": {
                        "error_kind": "fmtstring",
                        "length": 77,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "6485997221020871071": {
                        "error_kind": "string",
                        "string": "call to assert_max_bit_size"
                    },
                    "6753155520859132764": {
                        "error_kind": "string",
                        "string": "Failed to deliver note"
                    },
                    "7233212735005103307": {
                        "error_kind": "string",
                        "string": "attempt to multiply with overflow"
                    },
                    "8270195893599566439": {
                        "error_kind": "string",
                        "string": "Invalid public keys hint for address"
                    },
                    "8830323656616886390": {
                        "error_kind": "string",
                        "string": "Got a public log emitted by a different contract"
                    },
                    "12099279057757775880": {
                        "error_kind": "string",
                        "string": "DST_LEN too large for offset"
                    },
                    "12822839658937144934": {
                        "error_kind": "fmtstring",
                        "length": 75,
                        "item_types": []
                    },
                    "13649294680379557736": {
                        "error_kind": "string",
                        "string": "extend_from_bounded_vec out of bounds"
                    },
                    "14225679739041873922": {
                        "error_kind": "string",
                        "string": "Index out of bounds"
                    },
                    "14514982005979867414": {
                        "error_kind": "string",
                        "string": "attempt to bit-shift with overflow"
                    },
                    "14657895983200220173": {
                        "error_kind": "string",
                        "string": "Attempted to read past the length of a CapsuleArray"
                    },
                    "15366650908120444287": {
                        "error_kind": "fmtstring",
                        "length": 48,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "16218014537381711836": {
                        "error_kind": "string",
                        "string": "Value does not fit in field"
                    },
                    "16446004518090376065": {
                        "error_kind": "string",
                        "string": "Input length must be a multiple of 32"
                    },
                    "16954218183513903507": {
                        "error_kind": "string",
                        "string": "Attempted to read past end of BoundedVec"
                    },
                    "17843811134343075018": {
                        "error_kind": "string",
                        "string": "Stack too deep"
                    },
                    "17879506016437779469": {
                        "error_kind": "fmtstring",
                        "length": 128,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "18194595712952743247": {
                        "error_kind": "fmtstring",
                        "length": 98,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    }
                }
            },
            "bytecode": "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",
            "debug_symbols": "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fPzW77+l8Td+/3WN339d4/df1/j91zV+/3WN339d4/df3/j91zd+//WN33994/df3/j91zd+//WN33994/df3/j91zd+/5XG77/S+P1XGr//SuP3X2n8/iuN33+l8fuvNH7/lcbvv9L4/Xdp/P67NH7/XRq//y6N33+Xxu+/S+P336Xx++/S+P13afz+uzR+/w2N339D4/ff0Pj9NzR+/w2N339D4/ff0Pj9NzR+/w2N339D4/ff2Pj9NzZ+/42N339j4/ff2Pj9NzZ+/42N339j4/ff2Pj9NzZ+/02N339T4/ff1Pj9NzV+/02N339T4/ff1Pj9NzV+/02N339T4/ff3Pj9Nzd+/82N339z4/ff3Pj9Nzd+/82N339z4/ff3Pj9N7d9/5Wp7fuvTG3ff2Vq+/4rU9v3X5navv/K1Pb9V6a2778ytX3/lant+69Mjd9/58bvv3Pj91/z+1+Vxt/4/bfx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vpPH9r6Tx/a+k8f2vlsb3v1oa3/9qaXz/q6Xx/a+Wqe3779L4/ldL4/tfLY3vf7U0vv/V0vj+V0vj+18tje9/tTS+/9XS+P5XS+P7Xy3m9796fHSIeX4e/97B66hDCo8PztPHXK3fq2vO1fp9veZcrfcANedqvV+oOFfze3vVnKvxPiQu4j6OjmEKx3P1fj3Wy9Og3c6hS1jWIS9xejrYp70x57x98jSlT0ffMRpvh1rBaLwrawWjgLEGRuM9aisYjbe/rWA03lm3gtF4094KRuN+oBGM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",
            "brillig_names": [
                "sync_notes"
            ]
        },
        {
            "name": "lookup_validity",
            "is_unconstrained": true,
            "custom_attributes": [
                "utility"
            ],
            "abi": {
                "parameters": [
                    {
                        "name": "consumer",
                        "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ]
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "inner_hash",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "boolean"
                    },
                    "visibility": "public"
                },
                "error_types": {
                    "576755928210959028": {
                        "error_kind": "string",
                        "string": "0 has a square root; you cannot claim it is not square"
                    },
                    "2709101749560550278": {
                        "error_kind": "string",
                        "string": "Cannot serialize point at infinity as bytes."
                    },
                    "2896122431943215824": {
                        "error_kind": "fmtstring",
                        "length": 144,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "2920182694213909827": {
                        "error_kind": "string",
                        "string": "attempt to subtract with overflow"
                    },
                    "3305101268118424981": {
                        "error_kind": "string",
                        "string": "Attempted to delete past the length of a CapsuleArray"
                    },
                    "3367683922240523006": {
                        "error_kind": "fmtstring",
                        "length": 58,
                        "item_types": [
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "5019202896831570965": {
                        "error_kind": "string",
                        "string": "attempt to add with overflow"
                    },
                    "5672954975036048158": {
                        "error_kind": "string",
                        "string": "Collapse hint vec length mismatch"
                    },
                    "5727012404371710682": {
                        "error_kind": "string",
                        "string": "push out of bounds"
                    },
                    "5870202753060865374": {
                        "error_kind": "fmtstring",
                        "length": 61,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "6336853191198150230": {
                        "error_kind": "fmtstring",
                        "length": 77,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "6485997221020871071": {
                        "error_kind": "string",
                        "string": "call to assert_max_bit_size"
                    },
                    "6753155520859132764": {
                        "error_kind": "string",
                        "string": "Failed to deliver note"
                    },
                    "7233212735005103307": {
                        "error_kind": "string",
                        "string": "attempt to multiply with overflow"
                    },
                    "7506220854563469239": {
                        "error_kind": "string",
                        "string": "Dirty collapsed vec storage"
                    },
                    "8270195893599566439": {
                        "error_kind": "string",
                        "string": "Invalid public keys hint for address"
                    },
                    "8830323656616886390": {
                        "error_kind": "string",
                        "string": "Got a public log emitted by a different contract"
                    },
                    "10583567252049806039": {
                        "error_kind": "string",
                        "string": "Wrong collapsed vec order"
                    },
                    "11499495063250795588": {
                        "error_kind": "string",
                        "string": "Wrong collapsed vec content"
                    },
                    "11553125913047385813": {
                        "error_kind": "string",
                        "string": "Wrong collapsed vec length"
                    },
                    "12099279057757775880": {
                        "error_kind": "string",
                        "string": "DST_LEN too large for offset"
                    },
                    "12822839658937144934": {
                        "error_kind": "fmtstring",
                        "length": 75,
                        "item_types": []
                    },
                    "13649294680379557736": {
                        "error_kind": "string",
                        "string": "extend_from_bounded_vec out of bounds"
                    },
                    "14225679739041873922": {
                        "error_kind": "string",
                        "string": "Index out of bounds"
                    },
                    "14514982005979867414": {
                        "error_kind": "string",
                        "string": "attempt to bit-shift with overflow"
                    },
                    "14657895983200220173": {
                        "error_kind": "string",
                        "string": "Attempted to read past the length of a CapsuleArray"
                    },
                    "15366650908120444287": {
                        "error_kind": "fmtstring",
                        "length": 48,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "15431201120282223247": {
                        "error_kind": "string",
                        "string": "Out of bounds index hint"
                    },
                    "16218014537381711836": {
                        "error_kind": "string",
                        "string": "Value does not fit in field"
                    },
                    "16446004518090376065": {
                        "error_kind": "string",
                        "string": "Input length must be a multiple of 32"
                    },
                    "16954218183513903507": {
                        "error_kind": "string",
                        "string": "Attempted to read past end of BoundedVec"
                    },
                    "17843811134343075018": {
                        "error_kind": "string",
                        "string": "Stack too deep"
                    },
                    "17879506016437779469": {
                        "error_kind": "fmtstring",
                        "length": 128,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "18194595712952743247": {
                        "error_kind": "fmtstring",
                        "length": 98,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    }
                }
            },
            "bytecode": "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",
            "debug_symbols": "7L3dsvs4sN33Luf6XBBA4yuvkkqlnMR2nSqXnbKdK9d59+g/2qS0R6CwNwZiN7rXzdSeGVJE/1aL6NWgwP/1L//Pf/y//r///H/+23/9T//tf/zL//a//69/+S//7f/+D//z3/7bf7392//693/9l//rv//bf/kv//af/8/n//wv259/uFT/OuF//L//4b/++ff/8T//w3//n//yv7mNXPnXf/mP//X/+evvnG8f8p/+7b/8xz//Fv/9X1+OzyV9HV02Oo7NvnFo9PHr0Bi3x8dS/vf/41//xeVtxnBKyPtwYn0/HAr161BK5XU4bspwCu3DqeX9cNK200k+vQ7HzxhO9f7r6BpiZzhl+zo0bw2xwu+H89d5NHheHDwvDZ6XB88rg+fVsfPKNnieGzzPD543mC9lMF9KO19CcfsXwIWaXefr4uvmvg4PW3r6Um73b0FJl1wlX3KVcslV6hVXqdslV3GXXMVfcpVwyVXokqtc8t2vl3z36yXf/XrJd79e8d3323bJVdwlV/GXXCVcchW65CrxkqukS66SL7lKueQql3z33SXffXfJd99d8t13l3z33SXffXfJd99d8t13l3z33SXffXfJd99f8t33l3z3/SXffX/Jd99f8t33l3z3/SXffX/Jd99f8t33l3z3wyXf/XDJdz9c8t0Pl3z3wyXf/XDJdz9c8t0Pl3z3wyXf/XDJd58u+e7TJd99uuS7T5d89+mS7z5d8t2nS777NOW7H7aYjqvUp5URt92vUi65Sr3iKnG75Crukqv4S64y5bsfbotu+1VuJd63q7we7WLax+SS809HU2tVvoSvg2N4+o7E+3ckEsP4y7Eyf1s3LZ3xx5SPpxxSCcfRyd0DiKsHkFYPIK8eQFk9gLp4AGlbPQC3egB+9QDC6gGsPhMn+TNxpr1wijnScwANdxHdXjjdpjj3/uAS92GU/PysYdO2uOORytsSy+ODqfXUoC8Pi/Pt0L+Iyy8dtBGXX+toIy6/ONNGXH41qYx4ll/+aiMuv17XRly+wdBGXL4j0kacQPxi4vCcVxOH57yaODzn1cThOa8mDs95MfECz3k1cXjOq4nDc15NHJ7zauIE4hcTh+e8mjg859XE4TmvJg7PeTVxeM6LiVd4zquJw3NeTRye82riK3hO9yBe3kN05fjFias+dD7aUd03XXQx++eP/osNgc0p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3msa672msd5rGuu9prHeaxrrvaax3msa672msd5rGuu9prHeaxrrvaax3msa672msd5rGuu9prHeaxrrvaax3msa672msd5rGuu9prHeaxrrvaax3msa672msd5rGuu9prHeaxrrvaax3msa672msd5rGuu9prHeaxrrvaax3msa672msd5rGuu9prHeaxrrvaax3msa672msd5rGuu9prHeaxrrvaax3msa672msd5rGuu9prHeaxrrvaax3msa672msd5rGuu9prHeaxrrvaax3msa672msd5rGuu95rHeax7rveax3mse673msd5rHuu95rHeax7rveax3mse673mk95rPR7ec5Vc47STLMn5OK36b6e9PiFYtv0nlCU8ftzoS2svylrS17G1fj/2PhwvazhB1nBI1nCirOEkWcPJsoZTZA2nihrO2ZoE13Bk3ZW9rLuyl3VX9rLuyl7WXdnLuit7WXdlL+uu7K++K6dj841t86/jCZuw8Thh4/HCxhOEjYeEjefX9+b7aWnstDx2WvstRa7sW3j4b68caEJztxb0fqe5/Z0eG+u0djrwJeybyITteRMe194KdDs2wNrC48fkNX+Nvwoff9x2AW6LfuFl/CdvQ19n/G7x8fvFxx8WHz8tPv64+PjT4uPPi49f+vzbG//i829cfP6Ni8+/cfH5Ny4+/8bF59+4+PwbF59/4+Lzb1x8/o2Lz79p8fk3LT7/psXn37T4/JsWn3/T4vNvWnz+TYvPv2nx+TctPv/mxeffvPj8mxeff/Pi829efP7Ni8+/efH5Ny8+/+bF59+8+PxbFp9/y+Lzb1l8/i2Lz79l8fm3LD7/lsXn37L4/FsWn3/L4vNvXXz+rYvPv3Xx+bcuPv/Wxeffuvj8Wxeff+vi829dfP6ta8+/ZVt7/i3b2vNv2daef8u29vxbtrXn37KtPf+Wbe35t2xrz79lW3v+Ldvi869bfP51i8+/bvH51y0+/7rF51+3+PzrFp9/3eLzr1t8/nWLz79+8fnXLz7/+sXnX7/4/OsXn3/94vOvX3z+9YvPv37x+dcvPv+GxeffsPj8Gxaff8Pi829YfP4Ni8+/YfH5Nyw+/4rf/6o3/sXn38X3vyqL739VFt//qiy+/1VZfP+rsvj+V2Xx/a/K4vtflcX3vyqL739VFt//qiy+/1VZfP+rsvj+V2Xx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",
            "brillig_names": [
                "lookup_validity"
            ]
        },
        {
            "name": "constructor",
            "is_unconstrained": false,
            "custom_attributes": [
                "private",
                "initializer"
            ],
            "abi": {
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "kind": "struct",
                            "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
                            "fields": [
                                {
                                    "name": "call_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                        "fields": [
                                            {
                                                "name": "msg_sender",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "contract_address",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "function_selector",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "is_static_call",
                                                "type": {
                                                    "kind": "boolean"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "historical_header",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                        "fields": [
                                            {
                                                "name": "last_archive",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                    "fields": [
                                                        {
                                                            "name": "root",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "next_available_leaf_index",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content_commitment",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                    "fields": [
                                                        {
                                                            "name": "num_txs",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "blobs_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "in_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "out_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "state",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                    "fields": [
                                                        {
                                                            "name": "l1_to_l2_message_tree",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                "fields": [
                                                                    {
                                                                        "name": "root",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "next_available_leaf_index",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "partial",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                                "fields": [
                                                                    {
                                                                        "name": "note_hash_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "nullifier_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "public_data_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "global_variables",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                    "fields": [
                                                        {
                                                            "name": "chain_id",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "version",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "block_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "slot_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "timestamp",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 64
                                                            }
                                                        },
                                                        {
                                                            "name": "coinbase",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "fee_recipient",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "gas_fees",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "total_fees",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "total_mana_used",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "tx_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                        "fields": [
                                            {
                                                "name": "chain_id",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "version",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "gas_settings",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                    "fields": [
                                                        {
                                                            "name": "gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "teardown_gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_priority_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "start_side_effect_counter",
                                    "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                    }
                                }
                            ]
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "signing_pub_key_x",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "signing_pub_key_y",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
                        "fields": [
                            {
                                "name": "call_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "function_selector",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "args_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "returns_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "min_revertible_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "is_fee_payer",
                                "type": {
                                    "kind": "boolean"
                                }
                            },
                            {
                                "name": "max_block_number",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                                    "fields": [
                                        {
                                            "name": "_opt",
                                            "type": {
                                                "kind": "struct",
                                                "path": "std::option::Option",
                                                "fields": [
                                                    {
                                                        "name": "_is_some",
                                                        "type": {
                                                            "kind": "boolean"
                                                        }
                                                    },
                                                    {
                                                        "name": "_value",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "note_hash_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifier_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "key_validation_requests_and_generators",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                                        "fields": [
                                            {
                                                "name": "request",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                                    "fields": [
                                                        {
                                                            "name": "pk_m",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                                                "fields": [
                                                                    {
                                                                        "name": "x",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "y",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "is_infinite",
                                                                        "type": {
                                                                            "kind": "boolean"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "sk_app",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "sk_app_generator",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "note_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifiers",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "note_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 5,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                                        "fields": [
                                            {
                                                "name": "call_context",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "function_selector",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "args_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "returns_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "start_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "end_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                                        "fields": [
                                            {
                                                "name": "inner",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        },
                                                        {
                                                            "name": "calldata_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_teardown_call_request",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        },
                                        {
                                            "name": "calldata_hash",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "l2_to_l1_msgs",
                                "type": {
                                    "kind": "array",
                                    "length": 2,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                        "fields": [
                                            {
                                                "name": "recipient",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_logs",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                                        "fields": [
                                            {
                                                "name": "log",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::log::Log",
                                                    "fields": [
                                                        {
                                                            "name": "fields",
                                                            "type": {
                                                                "kind": "array",
                                                                "length": 18,
                                                                "type": {
                                                                    "kind": "field"
                                                                }
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "note_hash_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "contract_class_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 1,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "start_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "end_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "historical_header",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                    "fields": [
                                        {
                                            "name": "last_archive",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                "fields": [
                                                    {
                                                        "name": "root",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "next_available_leaf_index",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "content_commitment",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                "fields": [
                                                    {
                                                        "name": "num_txs",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "blobs_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "in_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "out_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "state",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                "fields": [
                                                    {
                                                        "name": "l1_to_l2_message_tree",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                            "fields": [
                                                                {
                                                                    "name": "root",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "next_available_leaf_index",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "partial",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                            "fields": [
                                                                {
                                                                    "name": "note_hash_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "nullifier_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "public_data_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "global_variables",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                "fields": [
                                                    {
                                                        "name": "chain_id",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "version",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "block_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "slot_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "timestamp",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 64
                                                        }
                                                    },
                                                    {
                                                        "name": "coinbase",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "fee_recipient",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "gas_fees",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "total_fees",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "total_mana_used",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "tx_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                    "fields": [
                                        {
                                            "name": "chain_id",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "version",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "gas_settings",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                "fields": [
                                                    {
                                                        "name": "gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "teardown_gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_priority_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    },
                    "visibility": "databus"
                },
                "error_types": {
                    "576755928210959028": {
                        "error_kind": "string",
                        "string": "0 has a square root; you cannot claim it is not square"
                    },
                    "2233873454491509486": {
                        "error_kind": "string",
                        "string": "Initializer address is not the contract deployer"
                    },
                    "2709101749560550278": {
                        "error_kind": "string",
                        "string": "Cannot serialize point at infinity as bytes."
                    },
                    "2896122431943215824": {
                        "error_kind": "fmtstring",
                        "length": 144,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "2920182694213909827": {
                        "error_kind": "string",
                        "string": "attempt to subtract with overflow"
                    },
                    "3305101268118424981": {
                        "error_kind": "string",
                        "string": "Attempted to delete past the length of a CapsuleArray"
                    },
                    "3367683922240523006": {
                        "error_kind": "fmtstring",
                        "length": 58,
                        "item_types": [
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "5019202896831570965": {
                        "error_kind": "string",
                        "string": "attempt to add with overflow"
                    },
                    "5727012404371710682": {
                        "error_kind": "string",
                        "string": "push out of bounds"
                    },
                    "5870202753060865374": {
                        "error_kind": "fmtstring",
                        "length": 61,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "6336853191198150230": {
                        "error_kind": "fmtstring",
                        "length": 77,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "6485997221020871071": {
                        "error_kind": "string",
                        "string": "call to assert_max_bit_size"
                    },
                    "6753155520859132764": {
                        "error_kind": "string",
                        "string": "Failed to deliver note"
                    },
                    "7233212735005103307": {
                        "error_kind": "string",
                        "string": "attempt to multiply with overflow"
                    },
                    "8270195893599566439": {
                        "error_kind": "string",
                        "string": "Invalid public keys hint for address"
                    },
                    "8830323656616886390": {
                        "error_kind": "string",
                        "string": "Got a public log emitted by a different contract"
                    },
                    "12099279057757775880": {
                        "error_kind": "string",
                        "string": "DST_LEN too large for offset"
                    },
                    "12822839658937144934": {
                        "error_kind": "fmtstring",
                        "length": 75,
                        "item_types": []
                    },
                    "13649294680379557736": {
                        "error_kind": "string",
                        "string": "extend_from_bounded_vec out of bounds"
                    },
                    "14225679739041873922": {
                        "error_kind": "string",
                        "string": "Index out of bounds"
                    },
                    "14514982005979867414": {
                        "error_kind": "string",
                        "string": "attempt to bit-shift with overflow"
                    },
                    "14657895983200220173": {
                        "error_kind": "string",
                        "string": "Attempted to read past the length of a CapsuleArray"
                    },
                    "15366650908120444287": {
                        "error_kind": "fmtstring",
                        "length": 48,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "16218014537381711836": {
                        "error_kind": "string",
                        "string": "Value does not fit in field"
                    },
                    "16446004518090376065": {
                        "error_kind": "string",
                        "string": "Input length must be a multiple of 32"
                    },
                    "16954218183513903507": {
                        "error_kind": "string",
                        "string": "Attempted to read past end of BoundedVec"
                    },
                    "17618083556256589634": {
                        "error_kind": "string",
                        "string": "Initialization hash does not match"
                    },
                    "17843811134343075018": {
                        "error_kind": "string",
                        "string": "Stack too deep"
                    },
                    "17879506016437779469": {
                        "error_kind": "fmtstring",
                        "length": 128,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "18194595712952743247": {
                        "error_kind": "fmtstring",
                        "length": 98,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    }
                }
            },
            "bytecode": "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",
            "debug_symbols": "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4nM29MWnbGb64nM29MXnbOiLz9nQF5+zEdicsqEvPmdDX3zOhr74nA198Tkb+uJTNgt98Tkb+uJzNvTF52zoi8/ZCGxO2dAXn7OhLz5nQ198zoa++JwNffEpm5W++JwNffE5G/riczb0xedsBDanbOiLz9nQF5+zoS8+Z0NffM6GvviUTaIvPmdDX3zOhr74nA198Tkbgc0pG/riczb0xeds6IvP2dAXn7OhLz5jM3b7dPlX2NAXn7OhLz5nQ198zkZgc8qGvvicDX3xORv64nM29MXnbOiLT9l0+5TAV9jQF5+zoS8+Z0NffM5GYHPKhr74nA198Tkb+uJzNvTF52zoi0/ZdPssu1fY0Befs6EvPmdDX3zORmBzyoa++JwNffE5G/riczb0xeds6ItP2XT7fLtX2NAXn7OhLz5nQ198zkZgc8qGvvicDX3xORv64nM29MXnbOiLT9nwvLtv2NAXn7OhLz5nQ198zkZgc8qGvvicDX3xORv64nM29MXnbOiLT9nwvLtv2NAXn7OhLz5nQ198zkZgc8qGvvicDX3xORv64nM29MXnbOiLT9nwvLtv2NAXn7OhLz5nQ198zkZgc8qGvvicDX3xORv64nM29MXnbOiLT9nwvLtv2NAXn7OhLz5nQ198zkZgc8qGvvicDX3xORv64nM29MXnbOiLT9nwvLtv2NAXn7OhLz5nQ198zkZgc8qGvvicDX3xORv64nM29MXnbOiLT9nwvLtv2NAXn7OhLz5nQ198zkZgc8qGvvicDX3xORv64nM29MXnbOiLz9gIz7v7hg198Tkb+uJzNvTF52wENqds6IvP2dAXn7OhLz5nQ198zoa++JQNz7v7hg198Tkb+uJzNvTF52wENqds6IvP2dAXn7OhLz5nQ198zoa++JQNz7v7hg198Tkb+uJzNvTF52wENqds6IvP2dAXn7OhLz5nQ198zoa++JQNz7v7hg198Tkb+uJzNvTF52wENqds6IvP2dAXn7OhLz5nQ198zoa++JQNz7v7hg198Tkb+uJzNvTF52wENqds6IvP2dAXn7OhLz5nQ198zoa++JQNz7v7hg198Tkb+uJzNvTF52wENqds6IvP2dAXn7OhLz5nQ198zoa++JQNz7v7hg198Tkb+uJzNvTF52wENqds6IvP2dAXn7OhLz5nQ198zoa++JQNz7v7hg19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",
            "brillig_names": [
                "get_contract_instance_internal",
                "decompose_hint",
                "lte_hint",
                "discover_new_messages",
                "notify_created_nullifier_oracle_wrapper",
                "notify_created_note_oracle_wrapper",
                "random",
                "field_less_than",
                "build_msg_block",
                "attach_len_to_msg_block",
                "get_random_bytes",
                "get_random_bytes",
                "get_app_tag_as_sender",
                "increment_app_tagging_secret_index_as_sender_wrapper",
                "directive_invert",
                "directive_to_radix",
                "directive_integer_quotient"
            ],
            "verification_key": "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"
        },
        {
            "name": "fee_entrypoint_private",
            "is_unconstrained": false,
            "custom_attributes": [
                "private"
            ],
            "abi": {
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "kind": "struct",
                            "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
                            "fields": [
                                {
                                    "name": "call_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                        "fields": [
                                            {
                                                "name": "msg_sender",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "contract_address",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "function_selector",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "is_static_call",
                                                "type": {
                                                    "kind": "boolean"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "historical_header",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                        "fields": [
                                            {
                                                "name": "last_archive",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                    "fields": [
                                                        {
                                                            "name": "root",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "next_available_leaf_index",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content_commitment",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                    "fields": [
                                                        {
                                                            "name": "num_txs",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "blobs_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "in_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "out_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "state",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                    "fields": [
                                                        {
                                                            "name": "l1_to_l2_message_tree",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                "fields": [
                                                                    {
                                                                        "name": "root",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "next_available_leaf_index",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "partial",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                                "fields": [
                                                                    {
                                                                        "name": "note_hash_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "nullifier_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "public_data_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "global_variables",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                    "fields": [
                                                        {
                                                            "name": "chain_id",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "version",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "block_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "slot_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "timestamp",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 64
                                                            }
                                                        },
                                                        {
                                                            "name": "coinbase",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "fee_recipient",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "gas_fees",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "total_fees",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "total_mana_used",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "tx_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                        "fields": [
                                            {
                                                "name": "chain_id",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "version",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "gas_settings",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                    "fields": [
                                                        {
                                                            "name": "gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "teardown_gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_priority_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "start_side_effect_counter",
                                    "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                    }
                                }
                            ]
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "max_fee",
                        "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "nonce",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
                        "fields": [
                            {
                                "name": "call_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "function_selector",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "args_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "returns_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "min_revertible_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "is_fee_payer",
                                "type": {
                                    "kind": "boolean"
                                }
                            },
                            {
                                "name": "max_block_number",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                                    "fields": [
                                        {
                                            "name": "_opt",
                                            "type": {
                                                "kind": "struct",
                                                "path": "std::option::Option",
                                                "fields": [
                                                    {
                                                        "name": "_is_some",
                                                        "type": {
                                                            "kind": "boolean"
                                                        }
                                                    },
                                                    {
                                                        "name": "_value",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "note_hash_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifier_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "key_validation_requests_and_generators",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                                        "fields": [
                                            {
                                                "name": "request",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                                    "fields": [
                                                        {
                                                            "name": "pk_m",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                                                "fields": [
                                                                    {
                                                                        "name": "x",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "y",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "is_infinite",
                                                                        "type": {
                                                                            "kind": "boolean"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "sk_app",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "sk_app_generator",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "note_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifiers",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "note_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 5,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                                        "fields": [
                                            {
                                                "name": "call_context",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "function_selector",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "args_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "returns_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "start_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "end_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                                        "fields": [
                                            {
                                                "name": "inner",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        },
                                                        {
                                                            "name": "calldata_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_teardown_call_request",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        },
                                        {
                                            "name": "calldata_hash",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "l2_to_l1_msgs",
                                "type": {
                                    "kind": "array",
                                    "length": 2,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                        "fields": [
                                            {
                                                "name": "recipient",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_logs",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                                        "fields": [
                                            {
                                                "name": "log",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::log::Log",
                                                    "fields": [
                                                        {
                                                            "name": "fields",
                                                            "type": {
                                                                "kind": "array",
                                                                "length": 18,
                                                                "type": {
                                                                    "kind": "field"
                                                                }
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "note_hash_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "contract_class_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 1,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "start_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "end_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "historical_header",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                    "fields": [
                                        {
                                            "name": "last_archive",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                "fields": [
                                                    {
                                                        "name": "root",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "next_available_leaf_index",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "content_commitment",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                "fields": [
                                                    {
                                                        "name": "num_txs",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "blobs_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "in_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "out_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "state",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                "fields": [
                                                    {
                                                        "name": "l1_to_l2_message_tree",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                            "fields": [
                                                                {
                                                                    "name": "root",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "next_available_leaf_index",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "partial",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                            "fields": [
                                                                {
                                                                    "name": "note_hash_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "nullifier_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "public_data_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "global_variables",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                "fields": [
                                                    {
                                                        "name": "chain_id",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "version",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "block_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "slot_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "timestamp",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 64
                                                        }
                                                    },
                                                    {
                                                        "name": "coinbase",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "fee_recipient",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "gas_fees",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "total_fees",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "total_mana_used",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "tx_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                    "fields": [
                                        {
                                            "name": "chain_id",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "version",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "gas_settings",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                "fields": [
                                                    {
                                                        "name": "gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "teardown_gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_priority_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    },
                    "visibility": "databus"
                },
                "error_types": {
                    "576755928210959028": {
                        "error_kind": "string",
                        "string": "0 has a square root; you cannot claim it is not square"
                    },
                    "2709101749560550278": {
                        "error_kind": "string",
                        "string": "Cannot serialize point at infinity as bytes."
                    },
                    "2896122431943215824": {
                        "error_kind": "fmtstring",
                        "length": 144,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "2920182694213909827": {
                        "error_kind": "string",
                        "string": "attempt to subtract with overflow"
                    },
                    "3305101268118424981": {
                        "error_kind": "string",
                        "string": "Attempted to delete past the length of a CapsuleArray"
                    },
                    "3367683922240523006": {
                        "error_kind": "fmtstring",
                        "length": 58,
                        "item_types": [
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "5019202896831570965": {
                        "error_kind": "string",
                        "string": "attempt to add with overflow"
                    },
                    "5727012404371710682": {
                        "error_kind": "string",
                        "string": "push out of bounds"
                    },
                    "5870202753060865374": {
                        "error_kind": "fmtstring",
                        "length": 61,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "6336853191198150230": {
                        "error_kind": "fmtstring",
                        "length": 77,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "6485997221020871071": {
                        "error_kind": "string",
                        "string": "call to assert_max_bit_size"
                    },
                    "6753155520859132764": {
                        "error_kind": "string",
                        "string": "Failed to deliver note"
                    },
                    "7233212735005103307": {
                        "error_kind": "string",
                        "string": "attempt to multiply with overflow"
                    },
                    "8270195893599566439": {
                        "error_kind": "string",
                        "string": "Invalid public keys hint for address"
                    },
                    "8830323656616886390": {
                        "error_kind": "string",
                        "string": "Got a public log emitted by a different contract"
                    },
                    "12099279057757775880": {
                        "error_kind": "string",
                        "string": "DST_LEN too large for offset"
                    },
                    "12822839658937144934": {
                        "error_kind": "fmtstring",
                        "length": 75,
                        "item_types": []
                    },
                    "13649294680379557736": {
                        "error_kind": "string",
                        "string": "extend_from_bounded_vec out of bounds"
                    },
                    "14225679739041873922": {
                        "error_kind": "string",
                        "string": "Index out of bounds"
                    },
                    "14514982005979867414": {
                        "error_kind": "string",
                        "string": "attempt to bit-shift with overflow"
                    },
                    "14657895983200220173": {
                        "error_kind": "string",
                        "string": "Attempted to read past the length of a CapsuleArray"
                    },
                    "15366650908120444287": {
                        "error_kind": "fmtstring",
                        "length": 48,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "16218014537381711836": {
                        "error_kind": "string",
                        "string": "Value does not fit in field"
                    },
                    "16446004518090376065": {
                        "error_kind": "string",
                        "string": "Input length must be a multiple of 32"
                    },
                    "16954218183513903507": {
                        "error_kind": "string",
                        "string": "Attempted to read past end of BoundedVec"
                    },
                    "17843811134343075018": {
                        "error_kind": "string",
                        "string": "Stack too deep"
                    },
                    "17879506016437779469": {
                        "error_kind": "fmtstring",
                        "length": 128,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "18194595712952743247": {
                        "error_kind": "fmtstring",
                        "length": 98,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    }
                }
            },
            "bytecode": "H4sIAAAAAAAA/+19B5gcx3H17CXgFjjcEgBBgAQJMGdy4wUGCRKzmIOYRIULewwCARAAAyL3EAiCBEAAzMo5UzmnX7JsS5ZsZVmygiVbyVawJdmSZSv93eTWbt3bmtnZ2+rDNon+vgL2prtfva6uDtPT05MIngqd7UHwi7anfieMtJf/t5cWwzX6n//uFNLNEK71CNd6hWsHCNfmGVkC1xYJ6RYL1w4Xrh0hXDtWuHackVIwMSTK/y8p/59L9+Xzxf5sMZPLDKWzg8MDhXS+MNw3kBnIFAYKo9mBXK44kB/oHxwe7E8PZvK5YmasMJgbSz8V/txWxUo3FbIjLnn+ZfI8c3jBcpttpINxtXb4M7M7/T6e/f5LOQ3lsxWVMNJmpL2dXS+HNrBBurmQOVbRnh3tery4z1rcxY7twLk3a4dOR3boLNuhA2zAQ0LZLgk9rLRAVwt7sALYEVQ7ezLI/EAOOsoLOTe4fQU3uP15v3D7Bh3hFh3h9rvBzaYd1duwG9ycK76jftm3L+PIDo76HWd26HOEW/AL11k79s1/XfXrrsbNLN0o8uDbhKtm5tzsbFez8Cc4Krx2mRUrKXOiJ2VuUyzzSZ6UuV2xzCdPUZnTzYXMKYr2C9rdlFm70z018INn2hOeGU0fcsgz64k9c57wzHvCs+AJzz5PePZ7wnPAE56DnvA8zROep3vC8wxPeJ7pCc9necLz2Z7wXOIJz+d4wvO5nvA8yxOeZ3vC8xxPeJ7rCc/zPOF5vic8L/CE5/M84XmhJzwv8oTnxZ7wvMQTnpd6wvMyT3he7gnPKzzheaUjnq38XPCqKSpzurmQeb6i/To8eV50deAHz2s84XmtJzyv84Tn9Z7wfIEnPG/whOcLPeH5Ik94vtgTni/xhOeQJzyHPeE54gnPUU94Fj3hOeYJzxs94XmTJzxv9oTnLZ7wfKknPJd6wvNWT3gu84Tnck94rvCE522e8FzpCc9VnvBc7QnP2z3heYcnPO/0hOddnvBc4wnPtZ7wXOcJz/We8NzgCc+NnvC82xOeJU94jnvCc5MnPDd7wnOLJzy3esLzHk94bvOE572e8NzuCc/7POF5vyc8d3jCc6cnPHd5wvMBT3ju9oTnHk947vWE54Oe8HzIE54Pe8LzEU94PuoJz8c84fm4Jzxf5gnPl3vC8xWe8HylJzxf5QnPV3vC8zWe8HytJzxf5wnP13vC8w2e8HyjJzzf5AnPN3vC8y2e8HyrJzzf5gnPt3vC8x2e8HzCE57v9ITnuzzh+W5PeL7HE57v9YTn+zzh+X5PeH7AE54f9ITnhzzh+WFPeH7EE54f9YTnxzzh+XFPeH7CE56f9ITn//OE56c84flpT3j+lSc8P+MJz7/2hOffeMLzbz3h+VlPeH7OE55/5wnPz3vC8wue8Px7T3j+gyc8v+gJzy95wvPLnvD8iic8v+oJz695wvPrnvD8hic8/9ETnt/0hOe3POH5T57w/LYnPL/jCc/vesLze57w/GdPeH7fE54/8ITnv3jC81894flDT3j+yBOeP/aE50884flTT3j+myc8/90Tnj/zhOfPPeH5C094/tITnv/hCc//9ITnrzzh+WtPeP7GE57/5QnP//aE52894fk7T3j+jyc8f+8Jz//1hOf/ecLzD57w/KMnPP/kCc8/e8LzL57wtIA+8Ex4wrPNE57tnvDs8IRnpyc8uzzhOc0TntM94dntCc+kJzxneMJzpic8ezzhOcsTnr2e8Ex5wvMAT3jO9oTnHE94zvWE54Ge8JznCc+DPOE53xOeCzzhebAnPA/xhOdCT3ge6gnPwzzhucgTnos94Xm4JzyP8ITnkZ7wPMoTnkd7wvMYT3ge6wnP4zzhebwnPE/whOeJnvA8yROeJ3vC8xRPeJ7qCc+0JzwznvDMesIz5wnPvCc8C57w7POEZ78nPAc84TnoCc/TPOF5uic8z/CE55me8HyWJzyf7QnPJZ7wfI4nPJ/rCc+zPOF5tic8z/GE57me8DzPE57ne8LzAk94Ps8Tnhd6wvMiT3he7AnPSzzheaknPC/zhOflnvC8whOeV3rC8ypPeD7fE55Xe8LzGk94XusJz+s84Xm9Jzxf4AnPGzzh+UJPeL7IE54v9oTnSzzhOeQJz2FPeI54wnPUE55FT3iOecLzRk943uQJz5s94XmLJzxf6gnPpZ7wvNUTnss84bncE54rPOF5myc8V3rCc5UnPFd7wvN2T3je4QnPOz3heZcnPNd4wnOtJzzXecJzvSc8N3jCc6MnPO/2hGfJE57jnvDc5AnPzZ7w3OIJz62e8LzHE57bPOF5ryc8t3vC8z5PeN7vCc8dnvDc6QnPXZ7wfMATnrs94bnHE557PeH5oCc8H/KE58Oe8HzEE56PesLzMU94Pu4Jz5d5wvPlnvB8hSc8X+kJz1d5wvPVnvB8jSc8X+sJz9d5wvP1nvB8gyc83+gJzzd5wvPNnvB8iyc83+oJz7d5wvPtnvB8hyc8n/CE5zs94fkuT3i+2xOe7/GE53s94fk+T3i+3xOeH/CE5wc94fkhT3h+2BOeH/GE50c94fkxT3h+3BOen/CE5yc94fn/POH5KU94ftoTnn/lCc/PeMLzrz3h+Tee8PxbT3h+1hOen/OE5995wvPznvD8gic8/94Tnv/gCc8vesLzS57w/LInPL/iCc+vesLza57w/LonPL/hCc9/9ITnNz3h+S1PeP6TJzy/7QnP73jC87ue8PyeJzz/2ROe3/eE5w884fkvnvD8V094/tATnj/yhOePPeH5E094/tQTnv/mCc9/94Tnzzzh+XNPeP7CE56/9ITnf3jC8z894fkrT3j+2hOev/GE5395wvO/PeH5W094/s4Tnv/jCc/fe8Lzfz3h+X+e8PyDJzz/6AnPP3nC88+e8PyLJzyDNj94Jjzh2eYJz3ZPeHZ4wrPTE55dnvCc5gnP6Z7w7PaEZ9ITnjM84TnTE549nvCc5QnPXk94pjzheYAnPGd7wnOOJzznesLzQE94zvOE50Ge8JzvCc8FnvA82BOeh3jCc6EnPA/1hOdhnvBc5AnPxZ7wPNwTnkd4wvNIT3ge5QnPoz3heYwnPI/1hOdxnvA83hOeJ3jC80RPeJ7kCc+TPeF5iic8T/WEZ9oTnhlPeGY94ZnzhGfeE54FT3j2ecKz3xOeA57wHPSE52me8DzdE55neMLzTE94PssTns/2hOcST3g+xxOez/WE51me8DzbE57neMLzXE94nucJz/M94XmBJzyf5wnPCz3heZEnPC/2hOclnvC81BOel3nC83JPeF7hCc8rPeF5lSc8n+8Jz6s94XmNJzyv9YTndZ7wvN4Tni/whOcNnvB8oSc8X+QJzxd7wvMlnvAc8oTnsCc8RzzhOeoJz6InPMc84XmjJzxv8oTnzZ7wvMUTni/1hOdST3je6gnPZZ7wXO4JzxWe8LzNE54rPeG5yhOeqz3hebsnPO/whOednvC8yxOeazzhudYTnus84bneE54bPOG50ROed3vCs+QJz3FPeG7yhOdmT3hu8YTnVk943uMJz22e8LzXE57bPeF5nyc87/eE5w5PeO70hOcuT3g+4AnP3Z7w3OMJz72e8HzQE54PecLzYU94PuIJz0c94fmYJzwf94Tnyzzh+XJPeL7CE56v9ITnqzzh+WpPeL7GE56v9YTn6zzh+XpPeL7BE55v9ITnmzzh+WZPeL7FE55v9YTn2zzh+XZPeL7DE55PeMLznZ7wfJcnPN/tCc/3eMLzvZ7wfJ8nPN/vCc8PeMLzg57w/JAnPD/sCc+PeMLzo57w/JgnPD/uCc9PeMLzk57w/H+e8PyUJzw/7QnPv/KE52c84fnXnvD8G094/q0nPD/rCc/PecLz7zzh+XlPeH7BE55/7wnPf/CE5xc94fklT3h+2ROeX/GE51c94fk1T3h+3ROe3/CE5z96wvObnvD8liOebcAzl+7L54v92WImlxlKZweHBwrpfGG4byAzkCkMFEazA7lccSA/0D84PNifHszkc8XMWGEwN1bGPlaxzP80RWVONxcy327Ts19nux/13KFov+944tudimX+ridl7lIs8/c8KfM0xTL/sydlnq5Y5u97UuZuxTL/wJMyJxXL/C+elHmGYpn/1ZMyz1Qs8w89KXOPYpl/5EmZZymW+ceelLlXscw/8aTMKcUy/9STMh+gWOZ/86TMsxXL/O+elHmOYpl/5kmZ5yqW+eeelPlAxTL/wpMyz1Ms8y89KfNBimX+D0/KPF+xzP/pSZkXKJb5V56U+WDFMv/akzIfoljm33hS5oWKZf4vT8p8qGKZ/9uTMh+mWObfelLmRYpl/p0nZV6sWOb/8aTMhyuW+feelPkIxTL/rydlPlKxzP/nSZmPUizzHzwp89GKZf6jJ2U+RrHMf1Isc3vw1B6fr5cLfIKRE42cZORkI6cYOdXqMZIxkrW2MJI3UjDSZ6TfyICRQSOnGTndyBlGzjTyLCPPLpf9OUaea+QsI2cbOcfIuUbOM3K+kQuMPM/IhUYuMnKxkUuMXGrkMiOXG7nCyJVGrjLyfCNXG7nGyLVGrjNyvZEXGLnByAuNvMjIi428xMiQkWEjI0ZGjRSNjBm50chNRm42couRlxpZauRWI8uMLDeywshtRlYaWWVktZHbjdxh5E4jdxlZY2StkXVG1hvZYGSjkbuNlIyMG9lkZLORLUa2GrnHyDYj9xrZbuQ+I/cb2WFkp5FdRh4wstvIHiN7jTxo5CEjDxt5xMijRh4z8riRlxl5uZFXGHmlkVcZebWR1xh5rZHXGXm9kTcYeaORNxl5s5G3GHmrkbcZebuRdxh5wsg7jbzLyLuNvMfIe428z8j7jXzAyAeNfMjIh418xMhHjXzMyMeNfMLIJ438PyOfMvJpI39l5DNG/trI3xj5WyOfNfI5I39n5PNGvmDk7438g5EvGvmSkS8b+YqRrxr5mpGvG/mGkX808k0j3zLyT0a+beQ7Rr5r5HtG/tnI9438wMi/GPlXIz808iMjPzbyEyM/NfJvRv7dyM+M/NzIL4z80sh/GPlPI78y8msjvzHyX0b+28hvjfzOyP8Y+b2R/zXyf0b+YOSPRv5k5M9G/mLENrKEkTYj7UY6jHQa6TIyzch0I91GkkZmGJlppMfILCO9RlJGDjAy28gcI3ONHGhknpGDjMw3ssDIwUYOMbLQyKFGDjOyyMhiI4cbOcLIkUaOMnK0kWOMHGvkOCPHGznByIlGTjJyspFTjJxqJG0kYyRrJGckb6RgpM9Iv5EBI4NGTjNyupEzjJxp5FlGnm1kiZHnGHmukbOMnG3kHCPnGjnPyPlGLjDyPCMXGrnIyMVGLjFyqZHLjFxu5AojVxq5ysjzjVxt5Boj1xq5zsj1Rl5g5AYjLzTyIiMvNvISI0NGho2MGBk1UjQyZuRGIzcZudnILUZeamSpkVuNLDOy3MgKI7cZWWlklZHVRm43coeRO43cZWSNkbVG1hlZb2SDkY1G7jZSMjJuZJORzUa2GNlq5B4j24zca2S7kfuM3G9kh5GdRnYZecDIbiN7jOw18qCRh4w8bOQRI48aeczI40ZeZuTlRl5h5JVGXmXk1UZeY+S1Rl5n5PVG3mDkjUbeZOTNRt5i5K1G3mbk7UbeYeQJI+808i4j7zbyHiPvNfI+I+838gEjHzTyISMfNvIRIx818jEjHzfyCSOfNPL/jHzKyKeN/JWRzxj5ayN/Y+RvjXzWyOeM/J2Rzxv5gpG/N/IPRr5o5EtGvmzkK0a+auRrRr5u5BtG/tHIN418y8g/Gfm2ke8Y+a6R7xn5ZyPfN/IDI/9i5F+N/NDIj4z82MhPjPzUyL8Z+XcjPzPycyO/MPJLI/9h5D+N/MrIr438xsh/GflvI7818jsj/2Pk90b+18j/GfmDkT8a+ZORPxv5ixE7oUgYaTPSbqTDSKeRLiPTjEw30m0kaWSGkZlGeozMMtJrJGXkACOzjcwxMtfIgUbmGTnIyHwjC4wcbOQQIwuNHGrkMCOLjCw2criRI4wcaeQoI0cbOcbIsUaOM3K8kROMnGjkJCMnGznFyKlG0kYyRrJGckbyRgpG+oz0GxkwMmjkNCOnGznDyJlGnmXk2Xa+YuQ5Rp5r5CwjZxs5x8i5Rs4zcr6RC4w8z8iFRi4ycrGRS4xcauQyI5cbucLIlUauMvJ8I1cbucbItUauM3K9Efutefsdd/uNdPv9cftt75cYsd+ktt97tt9Stt8ptt8Att/Xtd+utd+Ftd9ctd8ztd8Ktd/htN+4tN+PtN9mtN89tN8UtN/rs9/Cs9+Zs99ws99Hs98es9/1st/Mst+jst96st9Rst8ost//sd/WKRmx34Sx31ux3zKx3wmx3+Cw37ew346w32Ww3zyw3xOwZ/Xbc/DtGfP2/HZ7Nro9d9ye6W3Py7ZnUdtznu0ZyvZ8Ynv2rz1X155Za8+DtWet2nNM7Rmh9vxNe7bla4zYMxnteYf2LEF7Tp89A8+eL2fPbrPnotkzx+x5XvasLHsOlT3jyZ6fZM8msuf+2DN17Hk19iwYe86KPcPEng9iz96w51rYMyPseQz2rAN7joB9R9++/27fLf+UEftOtH3f2L7La9+Tte+g2vc77buT9r1E+86ffZ/Ovqtm3wOz71jZ95fsu0H2vRv7Tot9X8S+i2Hnq/YdArs/3+59t/vK7T5ru4fZ7sO1+1LtPk27b9Hu4/uBEbvPy+57svuA7L4Yu0/E7puw+wjsc3X7nNk+d7XPIe1zOfucyj63sc8x7Lq+Xee26752HdSuC9p1MrtuZNdR7LqCvc+29532Pszel9h5ettTQ39g9xnbcEJQDeVuIWgvx9t9uXafqt23afcx2n19dp+b3fdl90HZfUF2n4zdN2L3Udh9BfY5u33ubJ/D2ueS9jmdfW5ln+PY5xp2nd+ue9t1YLsuatcJ7brZYiOHGznCiL3vtveh9r7M3qfYve/HGTk+qA1t7Pfs8v8H/ug5C277/JvP4enmhsRR/uJhT/3fDdcTZXssKf+dbi5kuhmuNv5AenC4O5gYlPnnuhmmA/ws4Xe4wX9yD7INj5cm4gegt6f8d4LZkvJQHPe9l5Xjppfj6fdd5d/dgOei3jknbbvNEfi3sbLZcFbJhe7sCOGfXcYPJmBncgN9uexAXzY7WkwPjfb1jw3m+tO54UJucGQ4k84VsgOj/UO5dLqYK47k06N9g4XR4tBgITc2PDTYR9jniNi54rCBKgz1DQxnxob6xtLD+f6B3NBYf//o0OigWX8ppEczI32ZkWxmbGBgqFAYGikMZjJjxcHC2EAF+1wndnmqrdhwnhv8Sl91vhP8XIHwLyhJtm+MK14g7Ocx7orv1lTwL3SDX7H9RW7wK75zcalp29cEwr6k5MJvnhqDbLjUCX6mwv8yN/zzhH85w084sM8VbvArvnmlG/yKb17lxv5jhP/8Mn7AsDMDuWy2P2fXzAdG05n86Eh2wIwsw/n0SHpoJFsczGcGx/LZfG5kdGTYrK8PZcbSY0Mjg2MDT4ET9tVOuOcqvnONE9vnKmPWtYJt6mTO1EMn7Osax64XKmPJ9eHYk65awn6BgJ0dyo2kB8fSQ4WBof6ieQiTNpOQ/uLwQHGsLzs0bCYc2dFMJlPMm3+yxdH84PBoX2a4zzy5KQwbdRWb3FBy4S+Zytzphcr4fUPpwWJfXz/hv0gZf3i4r3/I2JPwX6yMnxvpK47l+it9zUuU8YcK+bGxQm6I8IeU8QuZdLGQ7a/45rAy/uBwutA3MFDxnxFlfDNfzo0ODlXuV0e17TNcTI+MZgbpXqxYxicdNpDuMWXd5TCYAH1BMPFeMwD9SeCqPZ9PgD7Oh9uH7uvIdjeWarmmhDjex2Bcu3CN9EhYL1LEerEi1ksUsYYUsYYVsUYUsUbLv922tXxlHL3RCX5ugPBvcoKfLhL+zS7wM9W51y0MP9DjX8F/KcNPOMBf6sb+Ffxb3dincs+0rIzvAnu5G9tU5mAr3OBX7jluc4NfmaOudINf6RtWucEfJPzVbvArc9Tb3eBX5nh3uMGvzFHvdIM/Svh3OcHPVOyzhuHr9Z3ZSt+21gl+roK/zg1+pX9b7wQ/X8Hf4Aa/smaz0Q1+pX++2w1+pX8uucGvzH3GneAXKvfIm5zg91X8Z7Mb/Mp67hY3+BX/3OoGv+Kf97jBr/jnNjf4lfnDvW7wK/OH7W7wK/OH+9zgV8av+93gV8b3HW7wK+P7Tjf4lf5tlxv8Sv/2gBP8/sr4vtsNfmUNdo8b/Er/udcNfqX/fNANfqX/fMgNfqX/fNgNfqV/e8QNfqV/e9QNfqV/e8wN/qjdT2f3Cs2d8xSetMdKcT6Upv1LtNeJdHDdney64r3OaJw1ca4/CVxdrIlzfcQH7cPXxG1cl8A1JcRhHXYJeroEPSkhDudnzWDtVsS6RxFrlyKWZhl3KGJtV8TaqYi1TRFrjSKWpu0129CeFsXapIil6ROattf0ry2KWJptW9MnNitiafbRDyliter4SPNet3OrdF+PoJsCxU1juvmcCkM7/M1527nqwXOquJiOwsyg+tx31ZplI5csX11cFURksOHskny91YyXgLjpMcoQBPUNe0oMw+IEnnPrAUyeNyFgtQvX0Jm5zTtCOHAMqiucCC8p/51uKmRyccrB9U/VTYTUSUg3EWSfaW7sk00APuczTbAP+jDWXSKoNuROhsXTT2Nl5On5b8rPr32z/H8qqG1HtDk9IcS1C9fIvpb7V6BsvG7QT93UQz4T109JfzJw2W6qfir5hTSYdQe19ay5aSdOvUp9W7cQR1i0iY77KU8/nZWRp+e/KT+/9uPy/6mg1qfRT7uF8vBr3E+/X/7dHVKeJeW/002F/n5pnMJ2wO2kuQk5bjsg/cnApd9V24FUT1J/QrZLClxTQhwu+iQFPUlBT0qIw4loM1i7FLE2K2JtVcTa06JY2xWxdipibVPEWqOIdb8ilqbft6K9osbBRrFs0PTVvYpY9ypiafqqZhk3KWK1att+VBFrrSIWPeDDeSbhB0F1roTj/ZLy3+mmwlP3blwflYNf4/qTwFWXT3WuJNlVmtOSfWa4sU+FzwyBzwzBPlSXM4U4wqK1Fn7PwNPPYGXk6flvys+vnVqusBRg2oD3DDOF8vBr/J7h+MTEsvG6QT91WQ9cH/Hm17j+ZOCy3aQj/UJq/91BbT0r2icdp145X6rLHiGOsGaV/+Z+ytPPZGXk6flvys+vnQl+yn0a/bRHKA+/xv20H/yU1w36qZN6yIzF9lPSnwxctpuqn0p+MUOwY3dQW8+K9knHqVfOl+pylhBHWL3lv7mf8vQ9rIw8Pf9N+fm1C8FPuU/ji0ezhPLwa9xPzynjdoeUZ0n573RToZCX6lIPvz/TI5QT2xm3tZ5f52K3M9KfDGr9wkU76wU+YX5AtksJXFNCHPpIStCTEvSkhDi8r2kGa6si1hpFrM2KWPcrYm1SxNquiLVDEUvTJ7YoYo0rYu1RwpL652Z47VbiZcNeRSzNtv2oIpZmX6jZHncqYmnW42OKWJo+oWl7rbYdKJdR0yd2KWK1aj+hyeuZMGfaP6btO9trtsd7FLE0y/hwi/LSnE9olhGfD/B7y0T5/+6gtu0p3mcXE6CPysGvcf1J4KrLp3qfLdm1V7Ar2e4AgWtKiMP77AMEPQcIelJCHI4ZzWBtVcRao4ilWcbtilg7FbH2KmJp2v5RRaz99dgY1mOKWJo+sUURa5cilmb/tUcRS9P2mr6qaftW7b+2KGJp+tcORSzNetT0L802pOlfuxWxNiliaZZR01c126NmGTXnE61aj606l3tYEatV5zmac8z984mnRxvS7Cc0eWn5l/2N66rN8HpQiZcNmrbXnAPQWIv73QjfBrdraNnYe2xxDc3JHqw6a2jS3rruoNYPFe2TiVPPnC/V5WwhjrDKrzVP2BPG0x/AysjT89+Un197dtkoKcC0AfeEzRbKw6+Rfe2esMHyH90h5VlS/jvdXBjA9VDSwXVzOyn6XawPFHD9ycCl31XbgVRPUv9CtpsjcE0Ftb6D/jBH0DNH0LMfq7WwrlDCiurDKN6GbiGfdn/L9VE5+DWuPxk47RcyUXaV+kuyz1w39qnsUZ4r8Jkr2Ifq8kAhjrDmlf/m4xFPP5eVkafnvyk/vzYC49GBLC22gQOF8vBrfDx6YdvEsvG6QT91Uw/x3/kg/cnAZbup+qnkF1L77w5q61nRPuk49cr5Ul3OE+II66Dy39xPefoDWRl5ev6b8vNrt4Gfcp9GP50nlIdf43760vIfvUF4+4zTnjmu1G+jDXk+bA9O6jtTTMdtD6Q/Gbhsn9X2cGBMu5J95jmxz+hYHP/hfKkuDxLiCGt++W/eHnj6eayMPD3/Tfn5tU3QHnjbwfZwkFAefo23h/XQb/O6QT91Ug/p9FhcPyX9ycBlP1n1U8kvpPGvO6itZ0U+xTj1yvlSXc4X4ghrQflv7qc8/UGsjDw9/035+bXd4Kfcp/FdvflCefg17qf3wf0ulmdJ+e90U6GYkepSD38o3S3YWg8/O9gt1Jce/vAA4R/sBr+P8A9xgj9Qqd+FTvALFfsc6gZ/lPAPc+M/Ff6LnODncoS/2Al+scL/cCf4+Qr+EU7whyvt90gn+IMV/z/KjX0q9Xu0E/yxAuEf48Y+Ff7HuuFf6f+PZ/iaaxGEf6IT/HSO7HFCUA3tQplIP81FjmPpEyH/ExbGka4kYLma90ll4/zxvu8ExofbIAzrhAaxuoU4F3V6fES5uf6eCK5YDhvwDJzJ2sSGLYpYJUWs3UpY0ty2GV7rFHkdpMRLmv82g7VAEatdCcsG/KBeM7wOVuJlfx/SolgLFbEOVcQ6TBFrkSLWYkWsw5WwbMAPKTXD6whFXg8o8jpSiZf9fZQiltbYYX8frYh1jCLWsUpYNuDaaatg0TNkt+td+UG36125IbfrXflRt+tdhZzb9a58v9v1rvwIzdVpPCQd3Lf4+KZ3X5GP/S4o6U8CV10+1fu7w4AP2gf37ywSuKaEOGyjiwQ9iwQ9KSEO9/I2g/WQItYmRaz7FbG2K2JtUcRao4i1QxFrqyLWnhbF0vTVbYpYWraXxu1W8VXN9rhXEatV2+ODiliabahVbX+vIpZmP6E51mr20Zq217RXq/qX5txEsx41bf9M6CceVcKyv/EethleGxV5LVDipYllw/qSHq+DFXlp2d6GcUUsTZ/AtfRmsNqVsGzQ8gkbSopYGxSxNP1Lk5eWr7ZyXzhTkZemr2rWo2a/2qr20vRVXFttlbat2X89poilOf+6RxFLc01hqyKW5r3CFkUsmt/TOvZCFpco/+/2GUB60s8AFrrhE/kMYKFgV2k/rCKf0Tj1zPlSXS4W4gjr8PLffG8/T7+IlZGn578pP7/22nLFpQDTBtzbv1goD79G9rV7+1/ePrFsvG7QT93UQ/xvwJL+ZOC03WSi/OIwwY6SX1DelBCHc/rFgp7Fgh6p7nHvWzNYuxSxNitibVXE2tOiWNsVsXYqYm1TxFqjiPWAIpZmG9Ksx4cUsTYpYu1VxNJs25r+pdmGNPvVZ4LtdyhiafbR1BdK71Epzj/S0ntOiviVdw4Oj7AF1497cShe+p+wMI50JQFLuWyZqLJF3bsdzvgsZr/DsA5vEEt6N85FnS4OwsvN9bt9F7CQdfsuYKHP7buA+THy+SOZPRNgu6Od1OVA7LNUSH8SuLpqU0cDH7QP3g8dI3BNCXG4d+8YQc8xgp6UEIfjdjNYDylibVLEul8Ra7si1hZFrDWKWA8oYu1WxNK0fav66l5FrK2KWJr+pdnn7FLEeibYfocilmYZ97Qolmbb3qaIpWV7+xv35baKr7bqHEATa/+4vX/cdtmv7h+394/b+8ftp9+4bYOmvVrVVx9UxNK0l2afo2n7exWxNNuQ5rjdqn10q84nNMuoOffVrEdN2z8T+olHlbASQe3+nGawFitiaa2T29+HK2HZgHuPm+E1U5HXRiVeNowrYpWUsOzvIwI9rKe77e1vfHeiGawFilgHK2HZoGmvo5R4afqqDZptqFX9vlXL+HTvCzV52bB/7PB/7LDhbiUs+1tzz4OWvezvQxR5bVDkpTXW2qA5PmraqxXHDhseU8TSvOe7RxFL85nOVkUszfWJLYpY+H4b3xuWKP8vnRdv9Swp/51uLowmQB+Vg1/j+pPAVZlPJsquRwt2lc67V+QzkgB8zudYwT5Ul8cLcYRF52Ty99t4+mNZGXl6/pvy82t/7njq/xRg2oDvt0lnpfNrZN8uI7/vmFg2Xjfop27qIRv7/TbSnwyctptMlF9I7V/yC8or1ReO+3HrS8Laroi1RxFrsyLWLkWshxSxtipi7W5RXlsUsdYoYj2qiLVWEesxRSxNe+1UxNJsj3sVsTT9XrMv1KzHexSxNPscTZ/YoYilaftNiliavB5QxNL0Cc25iea4rVmPrdp/afqXZnts1T5aE0vTv7YpYpHt6X6F398kyv93Q75EoHqvl0+APioHv8b1J4GrLp/qvZ5k12MFuzbyfTHiSr95HNcz1d/xsmGXItZmRaytilh7WhRruyLWTkWsbYpYaxSxtL6NZMMmRSzN9rhXEUvTvzTtdb8ilqZ/abYhzX5V0yc0+9VWbdua7VGzDT2kiKXZHp8J/rVDEUtzDkBjbW85js+3+XkkPI7riZrz8/yUrkfIlyj/3w38EoHmHHsw9nkdpD8p2MTFnP+EmHYl250ocE0Jcbh35URBz4mCnpQQh2NTM1gPKWJtUsS6XxFruyLWFkWsNYpYDyhi7VbE0rR9q/rqXkWsrYpYmv6l2efsUsR6Jth+hyKWZhn3tCiWZtvepoilZXv7G8/raBVfbdU5gCZWq47bmrbXnANo9tGa84lW9dX94/a+G9P2z8kbw9o/J993/rV/Xrjv/KsV54U2aNqrVX31QUUsTXtp9jmatr9XEUuzDWmOHa3aR7fqmKZZRs25r2Y9atr+mdBPPKqElQhq9zg1w2u9Iq/FSrzs75mKWJrPhzTtdYgir3ElXjaUlLDs7yMCPSwtn7AB321uBdtrtm3t9qjVhuzvw5WwbNBsj88E/8LzhprBWqCIdbASlg2a9jpKiZdmX2iDZh/dqn7fqmV8uo+1mrxs2D838X/ssOFuJSzN+YQNWvayvzXn5BsUeWmNtTZojo+a9mrFscOGxxSxNNcU7lHE0nxutVURS3P9a4siFp43NJPFJcr/0z5f3tdZPUvKf6ebCpnY5w2R/mRQO1bp8anu850X1Np1pmBXst1BAteUEIf3xgcJeg4S9KSEOHzm2wzWLkWszYpYWxWx9rQo1nZFrJ2KWNsUsdYoYj2giKXZhjTr8SFFrE2KWHsVsTTbtqZ/afLSrEdNXpr9hKZPaNbjDkUszf6e+lWaW+GcYEn573RToVCguQmfyySCibpxbqKjOzOQAH1BIM/rSH8SuOryqc7rpHrj9sF53XyBa0qIwzqcL+iZL+hJCXHYNpvBuk8RS5PXLiUs+3taoIOlXcY1ilg7FLH2KGJtU8TStNdeRaxHFLEeUMTaqoilafvtilhbFLE0y/ioItZaRSxa58O5hQ1Lyv+b4TA30JfLDvRls6PF9NBoX//YYK4/nRsu5AZHhjPpXCE7MNo/lEuni7niSD492jdYGC0ODRZyY8NDg/1u5w6Fwe5AHl918DMZwl/gBj9L+Ae7wc8R/iFu8POEv9gNfoHwD3eD30f4R7jB73d79kFmgPBPdINfaV8nucEfIvyT3eCPEv4pbvCLhH+qG/wxwk87wc+mCT/jBr/Sf2bd4Ff6z5wb/Er/mXeDX+k/C27wK/1nnxv8Sv/Z7wa/0n8OuMGv9J+DbvAr/edpbvAr/efpbvCHCf8MN/iV/vlMN/iV/vlZbvAr/fOzneDnKv3zEjf4lf75OW7wK/3zc93gV/rns9zgV/q3s93gV/q3c9zgV/qfc93gV/qf89zgV/qf893gjxD+BW7wK/3b89zgV/q3C93gV/q3i5zg5yv9z8Vu8Cv9zyVu8Cv9z6Vu8Cvzw8vc4Ffmh5e7wa/0n1e4wa/0n1e6wa/MD69yg1/pn5/vBr/SP1/tBr/SP1/jBr/SP1/rBr/SP1/nBr/SP1/vBr/SP7/ACX6hMv+8wQ1+pf9/oRv8Sv//Ijf4lf7/xW7wK/3/S9zgV/r/ITf4lf5/2A1+pf8fcYNf6f9Hg2qoYueKw+ZRSGGob2A4MzbUN5YezvcP5IbG+vtHh0YH88X+Qno0M9KXGclmxgYGhgqFoZHCYCYzVhwsjA1UuBdF7GZC9bnFmAu7ZMYq/cKNDD+hxn+ggn+TE/x0pV3d7MRvqvxvcWL/0Uq//9JA2Xcy6bT9buf28kYJOj96KStHJ9TJreW/6ZukNiwtVdMsZfE8/ReST/1v9e0s6+thtgqYHhuozB0ubGqedSRAXxDI+5BIfxK46vKp7kPqAD5oH9yH1ClwTUGcDfhculPQ0ynokbAeU8Rao4j1gCLWVkWsnYpYWxSxtitiaZZxmyJWq/rXJkWs3YpYexWxNP1L0173K2Jp+pdmG9qliKXpE5r9Ku1X7A5qx0K9sbmvsl+6GNQGiuNz7wTE3cjSn1OqpsPQDn/zMk038qw5VVxMh3z4vGmM4YfNGWwgO3axeM05DuF3u8HPke2nBxNtimXqDrEVxUv/ExbGka5kUGt3F/NDqWycP7aX6YwPt0EY1vQGsbqFOBd12hVRbq6/J4KrVA68v5H6I2n+Tem7I3jx9L2CbspLNkyyOEUbZqNsyNsi6Z/JeI4Wh2+/8aLlvAur5Od2ILvNh3Tnlap2QB+cHoIVwN/z4Vo7w+PB7T3jvh0HqEyNjgPctmMQN9l+zwbsG9DmNti6/jmsLbQLZUIfCltbaGfxPP2vplX1/Wf59wymc2aEzh7gzdPbcF5pYvpZrGztQpqZwJHS/7bMy9bfJeX6k2xHfLoh/9PJl6lMjfoyr0fkRpjkO1i3YfWSmF7lcvmcKmfU1xNRDvp7VNBH3FOQ1gaq4wPYdcU1rtjfSiP9SeCqPA5V5jAHAB+0D/Ut1oYzyr+XLh8aPWtoxarblxbbwJS97DeHTwEcpeFpeUgxSkFIOqx2Gy4t1ebDQKbsDWqbdQp0cfx24Rp2vSmBG7k52ebYspvbbmtW+XdPILuxDd1BrW0VXWEkrmuS/mTgsjusumYv8AmzPdnHUVMZTgS1zaJd0El8qS4PEOIIa3b5b95F8vS8vfD0/Dfl59cWlv0pFdQ274tLEzlITZ9fI/taP51Xxu0VyjMLyibVW6+AmxLyow15O76lNDGuUygbxXVFxE2PiOsWykVxSZZvKeSbIWBaDqumV/HCbMP9iqYvUt8U1reGYZ0LWDz/AYA1uw7WJYDF888GrDl1sC4DLJ5/DmDNrYO1HLB4/rmAdWAdrBWAxfMfCFjz6mDdBlg8Px5Jd1AdrJWAxfPjJ8Tm18FaBVg8Px7ZuqAO1mrA4vnxGLmD62DdDlg8Px7ZekgdrDsAi+fHY+QW1sG6E7B4/oWAdWgdrJsAi+envD0CFs4DDmPX98U8gPQngaurecBhQa1duX3wMewigWtKiMN+a5GgZ5GgR8Kao4g1VxHrQEWseYpYBylizVfEWqCIdbAi1iGKWNhv1Ruvryo99X/UeE35uO/ydO0sjTRGc4yw+QC/Z+PXD41RHn4NbXNoiL4wftw2dL8ZNf/ohXwS51QdPVGcKZ00Z761NDGOL7Hj/JYvB+M8nC+VHwBx3UK5cM7M6xXnzNxufM7cCeW5o3zd7XJcOs39L8xWuC4h/R8E8ZZrpSV313rapkgPlmeWoh6OdU5pop6pX+JLF+OUg+t3vcRHtpgTYYu5TnTnYy93zgVbzHFkC/LFevdt+EhRujeTxhK+PHpjcbV5SPfcNVcN3TiNJeXdKtLpgXQHwN+zQ2gtgXRz4W+a/iEPjsUD8ohafpX0S90I/e4Urtsg3dbiMqxUbdKJcNIy7LwIPXOa1DNH0OP25J2045Nxqk/5paUEXibSH3WCYdxugHRN1QmDUtmi6lk6YTAKK+6peITl9jSlap1GnazI9Td6siJ/Wsz7uQXluaGd1r0eHnVIfYXb3WO5vrj+SPqnaqd53J0u0lSd8qYgzgb8koa066RL0CNh7VLEelARa6ci1hZFrDWKWJpl1KxHzTJuVsTSLOMORawHFLHuV8Taqoi1VxFruyKWpk9otkfNNqTpE5r22qaItUcRS9P29yhiadp+tyKWpr00+8JNilia9mrVvlDTXpp9zjNhzqTpE5rjtpbt7W887b1V/F7T9vcqYmn6vWYZNfsJzTmApr0eVcSK8za2dF9P6aU3WKR1qWfKGywFSHdeqWoH7HPivsFSgGvtgfwGi8X+OZyOgG+/2OB2PTaXTYA+LGMA+pPAVbn+K2tW0vYwad2TbHewwDUlxOGXsKWtYwcLelJCHI7bzWDtUMR6QBHrfkWsrYpYexWxtitiafrETkWsNYpYmj6haa9tilia9rpHEUvTXg8qYmn66hZFrGdCPe5WxNK0l+Y4tEkRS9NerToOadpLs7/X9C/NPkezPWr6hOacScv29jeuwbSK32va/l5FLE2/1yyjZj/RqvOvRxWxaA1GepUIX2GQ7mEXROjh+RfEwJLuhym99OpR1FqP9OoRrT04egUnG1Uf0utLk1nrIbtlIB2u9fC+7ZAQrAD+zsC1sLUe3Le0o7yQRfZ1tB9N3GqO+xX5nlHcF9noq7Y8f2+EnjlN6pkj6HFry8ZP0cDXJviJuviKw00Mi5+CgqEd/ublte3iqgZO2OD1MRaC2SmkTUAcpX1Vd5XHS8o83O47nLo6ObdUTYdBqhMqr7XFSJN1gvtfOW/pdek4r3FLr+GnhPwHROg5ukk9Rwt6eoR8iZD/SQ9eQz0S56j19snq4VjUht2u3Tfu/2hn7v+4N5ef0I2n6N3M4vhzIAxS2yBb2Lbx5hhtw+3zpqmzIb7yxm3I2zYGyYZki7g27A1qbYhtu1coh9TuOcZk2r3EodXGiTkQx+t4LsTxOj4Q4ngd4/MqfoJ8AuJeyuK6II6f2I4nId7K4pIQt4zF8brGUG88+0YD4xn3mzjjmXSECuG6faUsl4vT73P9SeCqy6f6HFR6RVg6uZNsd6DANQVxNmwoVdNhXLtwrS0Ca7si1h5FrM2KWLsUsR5SxNqqiLW7RXltUcRao4j1qCLWWkWsxxSxNO21UxFLsz3uVcTS9HvNvlCzHu9RxNKsR83+S9NeDyhibVLE0rSXZhvSnE9o2ut+Raz9/eq+61e1bG9/43PQVvF7Tdvfq4il6feaZdTsJ7YpYrXqfHWdIhbNVykfv8fnzywdn2NQ+arowW7wK+ckRD3L5frxnp7ipf8JC+Nw3/aBbsoWuW87yg/42nicI0IXNIi1L88z4bbG80wkrlI55iraJM4XUKS1pUbrNurIVsdtrLKnYG6Enbj+Zt4fyUI6ek7YFtTW3fwQrAD+zsK1sD0FvUFtnXaH8CS9eA19hefvjNCTbFJPMqaeVJN6UjH1zGlSz5yYevbXz0Q9+7J+qB/mZxbRc1v7zOX2pKyTH6nPz2rCPROU/h3sa7h3JcPL2A7l5/0EHUXo9gtcjT8nQ1veKJQnIWBJz5ioTI1+KYa/o8e5ccywL8V0sXiefmuyyuWMhTJmgmHydxVpXxmlpzbbFVTLzdMgB0q/nXGgrwghZkdIuaaHYL6a+eKOpIwZCJhSuZJQLuTQDRwo/W5WrmezTYo8Df3N/WRZaSK3GYKuIOQa9mkzQuKi9NbLa3/zrwhhHPoK2ovnD7Mp+gqlfzzCV7oEDry8WK/IAdMkQzi8UuDAj60cWb5iTfmrPgEE/DhZJ/yNVYlV0CXghAUyg83z6qSMw9NRQPfjQ/F0QUcyhCPPa81D1TtaXFpcXQwxUBuAdYYoawvk4PZrn27GDWl/Be97MUhjCpXX5nvuwioupqPA38neP6+a3LwKsaT5kg1jpWo8T/9h1o9cvlDGbAvBpM/IRI1p0t4kSi/dM0bNubk/4n26pJvbEvvdAxvkWm+9oRu4SveicbmeO8VcOxvkmhR087HHdK4331Fcecny1ZVTtAOBRgC/cdzBNDheTA+hOhPS9cLfeKwydu+z4e8ZAj8pIGeJS3tQP1ATJVt9jjXRq0KaaBDITZTcHm+/eF5++0UucYeQjnTeCeXh6blOSn8X0yNNce6AclP6LwtTnJTAifh0Q37dYbd/kGy4JqgNFLc2mFh2HreOpT+7VE2HQRpaqUzWFqc0cLvG6xG5ESYfMnjdhtXLd/mQAR/25PruDMLLQX+3C/rQlhRvA9XxOsBYUv473VQoDCVAXxAE4jI/6U8GtbZ1scy/DvigfaRuOOLDnmvYbw5/HcBRGp6Wh+sYpSAknVTtBwn5MJApO4Hzn9hd9U+g2+JNH79HzDm0C9dwttUh8Jf0dDWppyumHp/Lg7upbcAPQN4qlBV3U9uAH2tczuLwA5ArgtpyUdxtEZgrIzBXRcStjoi7XYiznNbOrHLE4UVq6jR0SnUX1q7DsM4FLJ5/HWCtr4OFH5Xk+dcD1oY6WPhRSZ5/A2BtrIOFH5Xk+TcC1t11sPCjkjz/3YBVqoN1G2Dx/CXAGq+DhR+V5PnHAWtTHSz8qCTPvwmwNtfBWg1YPP9mwNpSBws/KsnzbwGsrXWw8KOSPP9WwLqnDhZ+VJLnvwewttXBwo9K8vzbAOveOlhXARbPfy9gba+DhR9G4/m3A9Z9EVj2N77txPPfB1j318FaAFg8P+XtEbAS5f9pOrmDXdebvmViv+VC+pPAVZdPdTq5I6i1K7cPvuWyU+CaEuL4WMTjuJ6dgh4Ja40i1jpFrPWKWBsUsTYqYt2tiFVSxBpXxNqkiLVZEWuLItZWRax7FLG2KWLdq4i1XRELx7Koeb39TTukoub1lI/3Z7jc1Q55eHqOEXbf0B7I9wP3xygPv4a2uT9EXxg/bhs6IabZ+xT7ezFgTfY+xf4+HLAme59ifx8BWJO9T7G/TwCsyd6n2N8nAtZk71Ps75MAi+fHvr3efcpdpYlYPH+j9yk3ANZk71Ps75ODiViTvU+xv08BrMnep9jfpwLWZO9T7O80YE32PsX+zgDWZO9T7O8sYDVzn5IDrKj7lB11sPKAxfPvAKyddbAKgMXz7wSsXXWw+gCL598FWA/UweoHLJ7/AcDaXQdrALB4/t2AtacO1iBg8fx7AGtvHazTAIvn3wtYD9bBOh2weP4HAeuhCCwbzipNxOL5HwKsh+vwOgN48fwPA9YjdbDOBCye/xHAerQO1rMAi+d/FLAeq4P1bMDi+R8DrMfrYC0BLJ7/ccB6WR2s5wAWz/8ywHp5HaznAhbP/3LAekUElg1Xl4InA2Hx/K9gv628MqgGCev80kQsnv+VgPWqCCz7+6xgIhbP/yrAenUdrLMBi+d/NWC9JgLLhhtLE7F4/tcA1mvr8DoHePH8rwWs19XBOheweP7XAdbr62CdB1g8/+sB6w11sM4HLJ7/DYD1xjpYFwAWz/9GwHpTHaznARbP/ybAenMdrAsBi+d/M2C9JQLLBtrN1SvkfwtgvbUOr4uAF8//VsB6Wx2siwGL538bYL29DtYlgMXzvx2w3lEH61LA4vnfAVhP1MG6DLB4/icA6511sC4HLJ7/nYD1rjpYVwAWz/8uwHp3HawrAYvnfzdgvacO1lWAxfO/B7DeWwfr+YDF878XsN5XB+tqwOL53wdY76+DdQ1g8fzvB6wP1MG6FrB4/g8A1gfrYF0HWDz/BwHrQ3Wwrgcsnv9DgPXhOlgvACye/8OA9ZE6WDcAFs//EcD6aB2sFwIWz/9RwPpYHawXARbP/zHA+ngdrBcDFs9PeXsErET5f3rO9Ql2Xe+5Uj6TAH1UDn6N608CV10+1edcnwhq7crtg8+5PilwTQlxuOb4SUHPJwU9EtZ6RawNilgbFbHuVsQqKWKNK2JtUsTarIi1RRFrqyLWPYpY2xSx7lXE2q6IdZ8i1g5FrJ2KWLsUsR5QxNqtiLVHEWuvItaDilgPKWI9rIj1iCLWo4pYjyliPa6I9TJFrJcrYr1CEeuVilivUsR6tSLWaxSxXquI9TpFrNcrYr1BEeuNilhvUsR6syLWWxSx3qqI9TZFrLcrYr1DEesJRax3KmK9SxHr3YpY71HEeq8i1vsUsd6viPUBRawPKmJ9SBHrw4pYH1HE+qgiFq451tsn95Ly76h9cpSPrzvhq5ntkIen5xhh+/DaA3l/3cdjlIdfQ9t8PERfGD9um6Hyb419f8OA1cy+vxHA4vkb3fd3EGBJ+/56hXy4T3RthB4bovaJro3Q8/Em9Xxc0CO9p3hraWLcrUFtWfE9Rfsb331czuLWQNwKoVz4niJvI/ieIvdBfE+R+xS+p8h9BN9T5HXO31Ok93HJRhvK17uhbNR2l5T/TjcZpK8roh15vSVC/g+C2mcTNqB/8C//JKZIT9sU6cHyrFHUw7HOLj31v9R+8fiORtsvz782BIuONrCBf+lxGYvn6R8o+7LFvgaO2pD2qN/Krp1XCkLLSnmpjeD4tqT8d7q5kCH8jW7wc1HjIy8T9incdo34F9eVBCxt20WVjfNHP+TjdZx5xIYGsbqFOBd1uj6i3NIYInGVyhHWNrmeqFOQN0bw4umj5k9kQz6HUbRhNsqG0hxsMqcgk90OgXTU77QFtT64IQQrgL8PgWvtQfQpyLxOu0N4kt56/TjPj/OwtcBL+p/04DXUI3EmPfw8C34q7RNwNgP5HT8yh79HNZ/F8/Rtc6qY7y5jSu95hbWVBNPHz8Kgukd+YUctLQvh9wE27uGJlsuEMs+P4EyY/LwRzpnO/UAOH4V5pKMxUpxHkq5e4Iv1g2WR6gT97i7BDmG2tYHPU/g8hqf/VIPzFO7fOE/hnCivdM+PpzFKeqLGyaSgp9n5gaRH4oz3bjbwdv55aOfkD9zneV46D6ET0v9qdhXzHyLaOe4fwjkN9n3YzklfWDtHv6H0X41o59Kc+dJSOGfC5O2cc8Z2Tum/Ce3c0bxGbOekSxrHsJ03Oo5J/bikZ0aTemYIelyPlzNAz3pFPRwLz2EKa68/hvZK9Sq1Vxy3efqPsfb6b9Beub9H1SeOHesFvdhmgiDeGmXUu8nYR9kQNXZU+qiIsSPqHsCGqHvcqDVhno6niVo3bY/Qwf2JX6c5Kx/TlkHaDZB2fUTasPs5+7tY/u32nrt/jNoCX/ulQHElgTPFjbP0zy9V02Foh795mayvXB/jRGfp3rAUgok2tQFPf6cytwm4GwGX9wFoLzpvDdt/qlwY2/47e2Q89BMbrivjub2vHEhj/fKA9Yv2wSDVL/G29bu9gfrldTgOcbzPxjP++BhJGNb2B5eVtmpbmkx72d5ke5Hsic8iuD0Jg9uzEzDOZP6+EPyd0uB4YQO1H2qzZL8OIb8NOPej9IvLOp/8sv1CWX9UewsCuV/gdsCzRkuBzEUqM6U9DfyRtzE9f8xnqB43AWeue7Mj3XHma1x/j8CHeCeFuI4muBYy/f3ZvvxoYWy4b6BQKCYAn7jiNVw7lM7q6BXSk623OrF1bpSaWnupir+F2dWGDha3GeI6WRxxtG3oWwsn8t/iiH8c+3P9KSH9uaVqukbqMiXowXu1ZrDWTxJrdjCxDUhjIZ/b4FjI5y/8PNjrQvrlOH0d9W3Y7/NyYj94NfR1JZZH0Yfy0nwU+7pNjnTH7etIf08QXrdJIa6Zvm60kM/kxwYLw6NjueJo/1giqB0T2oVr2NdJfjtLSO+4r0hLfR32Zx0sbhPE8b6OOEp9nZtxMZeOY3+uPyWkx74ubl2mBD3Y1zWDtX6SWNTXjbP8pfJvqa/DeepGoTy8r8P7shugT3LzSQd5jRD7VM7XBn4PvZHZCe2LOPwanzfzPLhmQ+lH2bx9qEfmR2W4WOAn7V3i5RrrCU+3UUhnl5BoHnVjcfWVNw2tLI5eWRxZWVzdHsj0sIhYfLydCiCdDfjlslXwNy7f3Ao4NATH/XIZ/c+xpKrj2Dj03sJueX4IXdgy0LWk/H+6ySDdOuJQ6+bxWjb2bQXpTwa1LudiW4e0tMntg8Ojm8cS2bT9cBM+MrDh5lKtbZAH+Yv06I7bD9tCnMeUtwp6egK5XUn/kx68hnokzvR3VFcb1jXex7rGdT3V9NjXxNmyFedRPL/G098IcfwRXSICH5dbxll/8WxYQuJTKipH5eOkLE6zPVseP2E80G/5dC2snUmfC6H0UVvJbKBHGlFbiyTf4r5EPiLVc1SbcvHoX9LT06SeHkGP67bbA3rCHtU9EtImwx7VpVk8T/8O9qjucajPsL7ryXKVqnFT1GayjbYZqZ+KajP1Xt0gG0qPWK8pTYyT/B3takOxNJHDrQIHaTxNCfkpXZx5CuenV0eZ2PMU0j9V85RlMe1K9lnrxj7pKN9cK9gHtwZg3fG+m7d96fZHetzHxwm8XXxfubFHbSmIajvSI/gnt//BbZHreRC2rXbGMcOw6PNIrrd98P4S60PR9/NU7o0R5Ub9VvhjIGm7LabHex7Ex1ekKD//8LvkW+iPn2Vz0k/3yJhBED0nRZt0BfJ4iY+9Kf3fCPNIqY75Y8PPwrjKbYlbjTYIdnhyK12M8V56jI/j/Qq+lQ54Sf2PNK/COXyj8ypJD2LF3SJI6b/O6gU/uFzvs2hxtsZz2xIfyTZh2zCobdhA/Qy2nTC/5G3jMig/pf8OK/8l8PVQ3v7CtgOFvdLYHkT7VwIEl+6spAT90mMRK0vKf6ebDNiXdTAdJYEPPr75CbQ3Wr5tF8oq2XVc0MuXjFOgdxz02nr8I/gxcZsR1LYzqU5wWzryvAniKf0vWD/7Mxirw7b0/6ZH1p0MZD8MayecK2+Ha0oT4yn9r5i9/hJyb8D5SFylNso/wt5oG70EuFL630W00ShfkuZ0uJVHaqPIOwHX4/oFpf8z84s/RszhuF/MnDWRA24prNc/4NxhSfnvdJMB65K3U6m/xLrsgnKNl6+3C2WV6rQk6B1nabB/KIFeqX/gr/QRj5sZZpgfdwqcbcA2R+mTjAO2uWVCmSU/kMbYqFc6+CvTUnosC6VPMa5R6340H3C7hpER1/142+ksTSy39JlgaW6FdgpC7ERzl1RQv0/m27ik+6UbS9V4nv7oss2f3DI3a2JZo9YkHD2OHEyAPrINv8b1T9WaRKN1u1bgXyyFp5famLTmYZ+d4Bou75NJL381fCNck9YpcD0q7N7meOgbpDUw7nd0L4c6bSiWZJ0cl+uU1jqxn2xkTa6eDST/j+Ofkp6oZ0t3KeqRtsNG3TOG+Stei1q74f0x9k0u1kjuZjzj3O+UWBnizG+lV06l7cnYdjtCbIdrJJR+Ket7z4B2FVVGG/h9KXKS7l1xHWA8qOqWOOO9K6V/Dhuj670+x8thA64HUPqzGSauB4yz/HH6XWk7zzhLQ3ykNoH3jfwesAR6JGzcuifhjAMOljNsrk0Y0tY1K0vKf6ebDIS3uYzH57xbBD6dkP4K8ON7gok2jbKZla2CXn5MNs61t4Jeaa5N3Pi9OK93rBN8Lo088Z6L0l/L2vPVMJfi4zsfT180S9bN7ws2R3DdJHAdZ7rwvoDS3xBxXyCteXKu0pyc2uS+mJPzfquzNNE+Uv8RtZ4Yt/+QthZuhDg+5sc5AiTOGNMVkh59ltLfItxTRb2ua/GXwnyL68H9AHexMkSNU1hXPK/VuWKWjMvHEm6zm0oTy0vph9ia+Spog2HrYbeHtEHpiAsbzgXdlH4B030X2FB6phT17D4hxMWZzy6LqWdtiJ4gph6pPJrzZmm9fjZwbvRZBs8/VXtEZoOeDYIex/Pm2PfUlTWjoLbdu7injjoWktuV0kvrJesj0peE9NLRU/yemvfhAejl99QluCa1c1xHbPQeK2qfl/T8s14/93CD/dzKUjWep//lAVXMx6Cfa7V9ZXOa1DNH0OO6z5gD5VkbUZ5GfYrnn6qjM+aAnrB9cm8Lef7Q6BE0X2T++cQk/TPquIupOibFxRrNM6E8T+c28hmlNvJx1kb+FtqItB8t6riTydo5rp6nQ31uUNQjrc3X85tvhDzTi+s3lP4NzG++FcNvJNuEHZXJ9U6Vv0VhRc0tpX1KUeuSUc9QeXqqRz7XJV9w+3py/P3ApD8JXHX5VO8TxoNa290t2G5mUF2bGiquymQHzi6OrFyzYjVWBgGmgolGLgEgpQ/gb8xnSXVAmrWCDhv4eXLckVKQH29EED8Op3pp68VLjfDukHIGQbxGyPOHNcKw87xKLJ6n/yVb5Ipznhd3HnpAGec8r7AOpF0oQzIkH9oeB3DOSSozpf/viDJvqFPmc6HMYefl8r8xnbR5ZnogL7BHPYicG0zk3qg/8fxTNbjPBT1hgy69IIz1Evbizy0snqffwwbd9jJmo2f04Tl8jdpZ0uPazngW64aI8jR6zrh0rndUPd3C0oRtzuoQMG3AF6Mp/exyXTo+m1t8x590oQ/z8ll/m6vkw5uZDx8EPiwtdE3VglojbSURTL6tTFV5orCk9pAAzjy91xPaTDEdpw/i+r2f0H4/MdHIJQCk9AH8jfmiJrSYFjtDcqRmJ7QSp7C0jU5o+UoSTmgbXSHm+flTcN4gdB0pW/NmIn/6WmI6cWVvHSuDNFELW5VPhOBjR8kPd5FshzuhKH2+PCDYCWTboU/9lurqwBB+QRCvrnj+qVrNPxD0uNjtZwO+5VnPN9LAK2wSuwQmANIHIKQny/hxgxybAJwFEwBplTjqqVGc0yqkHbvSACVNPMN2OdTza7RRh4BpA04IKf2LYULo5oSaQnrfPY0uxB6U8eAm6a2bpBDX1KGb/WOZdF9ff24sOzRQLPTh2EVc8VqcJ9WHCundrujlxUM3+cTfhg4WtxHiOlkccZQOonMzYcqPxrE/158S0vPFlEbqUhOLDo+LeuMLdzzZEPXBNko/zMbOOB9CWSuUJ+oDHe3wN/Zl2FfZsKT8f70aHqsTArDbNIELviFHaW9mduk8dGJZpEPqqO9oj9ARCNcSQbjtUEe7gHdBaWLchhjcpAU7jnFXCE+LId10L4SyNLqYslDg4/LJF9dZb/5yF8xf6j35urNUjefpD2fzl3Uwf5F24+A8LBHIcwfsU/ibeNKCMPYDlL7E/L3eB6x4OZEjx4z7AStKvxXmL452tIkLWqRrqk6GQ6yOoLprnfePzytNtBWlv6R8U2rr+f7exjAvDMH8cG8Vc1eDmBeFYL6VYe6J8Pt5wUR9je4o5fnx1BW8D11S/jvdXKh8LHSFG/zKhyWXC7bgZSL9ze6g5bqm6s1IqWxR9cw/Ao1tScJa3iBWtxDnok6XRZSb6++J4CqVA+cVkp55gk0o/W0RvHh6asPc9ykv2ZB/XFvRhtmo+uYf+yb9k/lYKNntIEhHY2lbUGv7FSFYAfx9EFxrD+SPhdo+86/K/bw0Ls0M4Uwc6o1LPD/6v5s+s39EepOXgvQmL+eIoR3+5rxtfR88p4qL6TgG+jF+TDCqzw3DkNY+67V7G/jiPT0oXrV6+criZStvvmNodfGcO4rLVgv+Oz2YWD70OzzpeQWk5euZPB0+nF0Of6+Gv28X+GBAm/DQI6QLC/Xax7Hs92TaB88fta64qEk9iwQ9UVjHClhR/fciIf0zpf8+EtLRvV0z/feRcC2s/0Yu/P6JNtHwNoZz52/D/ZCbOclgrieo7dOoLKT7Nke6E6AvCOR5KenvEfgQ76QQ18x6bnYgl8kMmEfBxXQ+PTSajmpj/Bq2yZVC+uOF9GTr1YETW4sfFlnJ7GpDB4u7DeI6WRxxlNZz3fQbg7Hsz/WnhPS4XhK3LiWscyeJReu5vO+ltu22rTc+/8K3M6NOtOTPLfjaMwZp3kbltf50VYx5Gz535bzd3pdPnQ25r2KQbEjlbdSG3NfQhm7a8tTZkLdRDJINqbzWhiMN2JD7Gq5h876JeLeafRMQx59DnVOqpsNQz4bPasCG0jp4e1Brp1sFLLwPGRX4UDlvDyby5/VnAz7X4vlvB6y76mDhZmmeP86bcxzrEsCK2r+wvg7WZYAV9abMhjpYywEr6jTEjXWwVgBW1MlMd9fBug2wwk6+tVKqg7USsHj+EmCN18FaBVg8/zhgbaqDtRqweP5NgLW5DtbtgMXzbw7Jx/s3G3qEa9TW3X54LtPwB1ml+wUXa9yS3aV5Idlui8A1JcTxcZvHcT1bBD0S1jJFrHWKWCsVsW5XxLpLEWutItZ6RawNilgbFbHuVsQqKWKNK2JtUsRaoYhF68jSOuhtoKfRdVCeP846qNSHzgyqzwyeXDc/a2jFqtuXFgMIfN5KOvjfq0P0p4T8QQQWzxNVFj6nxTUK6ufDvmCBezoo/Tllxfz0rm4hv+J9x5D0UhcFisPxgcfxees5pYlx0pf8EoIe6Z6Eymtt8Vw4HToQsKRnC9wnDoMyrAb9eA19neendJKeRU3qWSToicI6TMCi9NI9RdSzBWkfmeMv4VSeLUj3eNJ9yWSeLZDdDoF0+GxButdDrAD+PgSu1Xu2QFzCXgDGZwuUfkXZt7sFrnr1MZCLem/B7T71gdjPFkh/j8AHTwrH/ZBLJsl1bCCbHsmNFdOF3PDwSHo0qo01epLEkUJ6t3vqBsRnC3wdzIYOFrce4jpZHD9xHJ8tuOk3BtJx7M/1p4T0OG7HrUtNLHq2wPteattu23rrPlvgexIaWRfn4yUeQsBteDT7zeOID17Dej9a4Noj5EuE/E968BrqkTjjcxQb+P7n8VQ1D/crvv+Z572jVI3n6XvZ/uctEXs28B4dfZX7hg3YTvipsHHGQ0q/nc2Vcf+z9G7FHaVwzqSjg12Pen+L0u+CMdnNuCjvfyZdUSfdoT2CoFonUe/GSe/guS1j/6j0/gAFqb/BPbR8jQH3HpRY3EqIG2dxuK6H9/Q8bjOLWw1x0toaxW1lcfhOKj/5nPsoBqnP5IeyfKOBPlP6Ug/eE3L7SvuQjmG/eRxxxWvobzz/ipB82I843vOUcdymK/uKpXe2eJlwriut08cZX7iuqVpHl8oWtVeDrzPgOrKEta5BrG4hzkWdrowot9QnSFylcuC6oNTOjhFsQunXR/Di6aXDhqZ6PUCyodZ6ANntREhH8462oNYH14VgBfD3iXAtbD1A6keXhfAkvfX60bjvmPD54idTss647/tT+t+x95s+zX7jmhzHWhpMjFvK4taUfzveXzUgrXcEYLs1TDfeA60VyhN3zOZ7qE6Z5B4qzo1j8vq7k6UJW3v+EptPn7FQxkwE8j0EzunJJ+K+00jpvxYxp6c0HSHlWh6C+e/MF/8xxNcDAVMq121QLuSwAjhQ+m8L6/pBUNv/ch+yYVlpIreVgq4g5BqOOStD4qL01strf9/BfmMc+graywo9nwqzKfoKpf9hhK9I73JE7SlFDpjmthAOPxU42PFoRjl+ZPmKNSGPszrYb+yeparEKlgm4IQFMoMtHjUHxKG/o9xP2v7K894WwpHn5WdcjRaXFleHPe9rA7BbQ5S1BXJw/F5UWtqDT0HaR4jjBm/LSyFuFYvjfS8GaUzh71PFfW62fdpTv6dqThJnrmHDWKkaz9P/kbU7/ILcCsZDwuRfj8aGFbU2Qunr3a+RfrKlNO+P0i3ta6T06xvkKj1r4HPolcA16pDMelzPnWKuKxrkKu1j4H216YxuvqO48pLlq4u8eSCNAH53wzVMg9tcbwuhOhPS4TIyHjGC4wO+5rdK4CcF5CxxaQ/qBzyveGZ5+fjJJfyQJhoE0dsppG3GfGr5Sbi1kB6hRLljnGM5eNfEMfDYEEo/l5Ubu6a4H/2l9NJ2Wb4EikvAvBngsU/8MR9f0rWhg8Up3sqPSh/v4zboLMUvr2SfkpBeOp4xBem5raRHLbgMyocwflbuOPifdGRZVNmithCV/wz9uCp+EI/SHxPhf+MCB+m8WUovbWUeZ2lwSbjE4iiv5H/8lQobOlicov8VJf/jNkD/iyqvZJ/NQnr+yIDqNwXpua0ojvsL6ZT6P7I5P+pIeoybCPmfuOK1qEfbF5cm6nH1cRN6zIb9pTSVs7/T5d801ee213z8hu2HL0FsEvjUfET5gInl2sLsI/Xr6WBi+s2CXv6I6VbQuxn08o/k4pKzDXw58CzgOs6wcdk9qswvZo+Pzy3/jppm4tGYFzDu0w8Nz49jIJ+r4REAUR82lY4J476J/S2lv5TxnFHmKfV5fPnchg4Wp+irY42OueMsLs6YW29MwHGVtw+8/ZFupbjNw25/wj6Ky4+q5emvZ3WEH8XlYzt+0PeuBrnHncOuY+VYAsd2RdWHxGMTw5LS8/bL048INkFM3hZ4HZdCMMcY5jUNYt4SgnlzxHxGGn+lc9Wx3+Xp+ZhMfKTXqbZAHOeO4+5mph/TvhT08zjetlBvEMEXx+x6fLHPpbgS67NXl39LH6B38chUqsvjhPLErct1EeVHLD6+or9KbWizYK91B8iYnQ1ibhTGPWmudGupqrsUMmbbgGO2Ddg3rRN48bmAdH+DjwGJ2z1Ce91n9wCZYloaD7kdcTyU7tOivqNREtLze1C8B+DpX1qaGBf1rRBpeSzueMOPGJ0b41sspDNqvcL+ng/pqdy8j+c+M8biefpHIvr4ksBB2vYR5fsllgaPDeV1RXmjtkbvC3+Nmr+VhPJubMI+6K+838Rjt7m/4OuCWv4agL9KfZBUl9h+SgIfqZ2inbpC0hMejqFvizGv4hyiXhWIu74gjXGbA1k3b5slho8fAKX0726l/jydyUjtg9sV20eUDW1odI5YKv+Oep1Uah+bIE5aq43T79oQ1XYoL/8IrHRvHHYEdD2dyFG6X5b6ekr/6Yi+Xhp7o/r6kpBe6gOkvoPy7rt7ddmXuQ3i9PVR9zvjQvoSSxPV1+O9sLQVuF7f/ZkI/8PHynG/LxblKxuFsjX6bGRf1v1UPhsJm5eirbhNOJbUN0StqTQ737QBv6Vbb76Ja5OU/gcNzjej/HBcSF9iaVp6vjkJPywJ5d2X802pD+LrhG+L6INwzif5X9T8rF4fhJ+vkvqgdoEXH4ul10BtWFL+P91kiHqm4/g7pYUE6CN78Gtcf1KwoyKfTFS9SmsAbj/nlM7bbkp6HndzqdY2Yf0O9uH0LM2GyxgO+Spua7aBPx/6E6w1SfNAnpd04DywfXYVM5g9EVM6Vo33wTj/lY5Vs7gPQ9vnNsH5h1TnUfPlEtMjpedjE08/vVxW6f5wXOAQtfZU71kM3h+XWNymQNYt7TeQxlJKP4uVZ9/fH2Yz+/qZP45ZUfeO3AfHQY80Fkmv0UqvIfB7QGyva1m5pLaFxwxKr3+HcbSBnpNiu8Q2IZWJjuzD+doiwcewHQYM8wB2rdH5SNSaEtZRKaiGqDpC3V1Ceo6HbeyYGH1G2LoO2pTSHx9hU6lNRNm0XpsolX/HWacqCVjcprjNVHr+GWVTSp+OsGm9tTK0KaXPRdhUslGUTeOuQ0U9q4xrU9wSTXri2pTSnxZhU/68KI5NKf2Z+9CmvMxbIF+JxeH8GPu7ZEi+VATmeAgmXef5oo42lepS6tOwLs+LqEupXOMxy7VJqVybGiwXpb/YUbnWhpRrbYPlGq9TLnzuSumvjFEuaZ3EBlz7p/RXx5zb7cu1iqlcL8U1Ue4bayFO2rMZ5ROTub+5He5veDqcq0n72TkP9AFKX4zpA1Ozp1z2gajn+dI8Ouqeqt6aDtazdMyR5AO4piodyRJ3fs+PzFkxa2I6zicR8j/pxGttMcqGbYvfR3C70n1EK+zN5Xyw31wHaw/S3tySgIPja9jeXNxrtRn0Sntzw9ZeNgBXPsbFWXuh9LvZ2kup/Fua8+D+2RKLwz5NGmO4P4SNMVtj9i/Eq9XGmHEWF2eMaWb/bAmwpHFE2j8rrTfgMzzpuYz1j8/31OdfEvJi++gKoueD2D4eipjPbGZ5pPvNTAjm48zvH509sfy8Hmlflk332tk6ul8RcR8j3ZdEPXPaKqSXjqLuBQ48L5Yb6+q10C9Ia1xoEz5v5ulx3iztg0wE9e8HNgtlRBt2haTnfSVP/xbBz1JCOcdBn8Qv7vg9zrhuiNH/ks6oT7/bgH4SNfexv/EZOV+/5s/XnsxfqsZNTV+cze7ruR4+m+T+sB6wpL447jNy/PyQdNyO9ZVHypWBc/RPMB/GfffSvF96po6Yn4roryS7RflhSUgv7UWQ1pxLEfmk56Rc15Ly/+n0WFOB9I2X8aYJXEgvzrU+x+zYeajMNVHDt7kQdS/QHcj9ro7ubDoB+oKg9l6D608KtlS8P8hE9dfSPM3t/UpmjD/T5f7Ln+nyupHmf9I+DX6f8FWYs0h9AO/nTmXxPP232HzpGyGYQRDd39XbI/bjmRNxSwKuxpqN1LeMQxzPh8+BeJ1g31/v3SbcC0npf8D6hqh3B4mX273nY/t8by3ZTNpbG+d9CO4L5wHX8p8T5ofjAj4+r/95xPwwan/v+ga5bxS4YzvHtvNVmDtyneti6Gxmf+98Fs/T/3YK5w379/fWpi+xNI3s7+X+End/7+fLfbf0XnaczxtKa95RYxb37wUsnqefVj6GrZXPXyE7Ofa/7L7eY0z1G+f8lai9ndJnaaz/PVH2P5d27B9IV+a0VIf8WHkeOlg8T7+g7JNJVg76v6lPkvQPZcZyQ2NDhaHR0fzIEB4TbwPVmT3myvrD3DlVm5GdtG1mA+F3usGvvDfcwcraLpSJ9JMvtbH0iZD/g0C+ZyFdScBSLlsmqmycPz6v6QA+9DsMq6NBrO6QuCU65a7UaXtEuVF/WHqpDdD1rgh8np76de7DXWCLaW5skY2qty6mk/RP5hhs+nshpMPPYnF7d4ZgBfD3QrjWHsjHYGO/1BPUlpvyOO5TsnH7AdKfDJy2h0o/0Al8wtouP85w6fKh0fLJqtjlYdVxc3I4LDZWXWVYhGvoDm2Qj6Z60hCKPBMChmQCwuwNJnLgeaWupD1EbxBU3RW7j3pY9Ls9gksYRgIweiIw9jed/U1HCPubTrymoz0bzw4M9A1mh9P5/tGRsdF8rt5sXFv/yHDfcL44PNKXyffl8unRRu4GcLbB77rbBft1Qvpr2V03PoFqi8C0AU9SpfQviLiTl2ZFUjnjdAOcT29Q61d4BzFV/tQ/NDA8ODKYH8r3pUfS/X2TqU+p3Nz2t5cmpqeZZVcQfTfVCelvYnWFuzW6WB7CurNUi4mcef3wGTt+jI3SL2UcZrHVdLQDDol8Nq04BI0kQF8QyEMi6U8GTofoDNYH8UH74JMwR3c4wwnA53ymCfahupwuxBEWrQTxvoann8bKyNPz35SfX1tb9q0UYNpAp6MmhLh24RrZ98lT1mDqxusmEfI/4eI1vIPntsE+jPef/Mnh3SH9B7cnz0v9B7bFPXOqmJvKv6X5BdYf9slR8wSuL6y/wvGK0m9jfQV+PATHK15O5Mj1dQh6bcD+itLvgJU4R+1e/Hgk6ZLGu0Qg2yMI4q1CSeNjj6CH7DUjiF5pieonola8qM11haQnvE5I/0jEWDad5WkXeOFchtI/HjGX6RbKJbVrup4U0ncL5eoNavs/yis9lSDbOz6hdkR6KsFt2Fmqb59pTdiHfCAF6bmtpD50Guipd2uJT3GlVTTe5/L5W6+gH8sptYcuoZxR7UEqH/ruEw3O7fiHdqeFcIg7t6P072EcDoiY2/Gx7H1zorlif8PvfXj6j7Kx7INQP9jn2CD1g+0Qx+uSbMT7wS4BV2rP6BNSW+Hpca5Nvt8Vkp7Pp3j6T0X4RJLlkeaXOGeg9J+J6CNnBLXl4vcxaIeZQvoZQa0deoPaPmBmIOvm5eF2xg9oU/q/E8oj9bv8iYINHSxOsd8Vv8bB7Yr9bpQNbUCb9wjpuS2pfClIz+0vtZ0ZEMf1TgcO9e5tsE+W5hu875CWV7kNiGe3UF69uhvJJEAflY9f4/qTQa3Pu7iXjOsjZJ8eN/ZJR/lgj2Af4jPLCZ90jnwlJegmrvSmOu9XePoeZkOenv+m/Pzaz8Bfe1k+wk9BnA14H8vj2oVrbfsIKyVgcbtRndp2/H2wBX7ZSvqfcPEacuT1ST4f1UdMVg/HovmN1J6sLCn/nW4q5LJUjllCOUg39yu9tlPoj9vXkf5k4LQtZ6J8mNsH73VTAtdUUOvD60vVdPX8m+uRsPa2KNZWRawdilgPKGJp2mu7ItZORaxtilhrFLE0y7hLEUuT12ZFLM32qFmPWxSxNNvQHkUszXrU9NWHFLE0/Wu3ItYjiliaft+qfY5mGR9VxFqriPWYIpamvTTnJpr+1arzQk2/b9W53CZFrPsVsZ4Jc7lW9XvNucn+Ma0xrFady7VqX6g5l9PsCzXrUdNerTr/WqeI1arzr3sUsTTbtmYb0rSX5jik2YZa1faa/Zfmupzm3KRV/Utz7tuqc8xWHDvsb3xmpTF2SM96+R7FboGH5vNewp/tCJ9sdUCErbh+fPZL8dL/hIVxpCsJWMply0SVLeoZMX8ezm0QhnVAg1jdQpyLOk1FlJvr74ngKpWjR9EmnYpYuLdN2rMhPVel9LOF9JKf9Aq6KS/V7RwWp1i32ai65X0E6Z/M29tkt6shHX3NoS2obRsHhGAF8PfVcK2d4fHQG9T62vQQnqQXr6Gv8Pw9wIP+pj0vfA8s7ROR9vZYWVL+O91U6MtG9a1ux5m+XNy+m/RPVd8d1YfZgHsj4vRhNmwsVdM10+/Y8LAi1gOKWFsVsTYrYu1VxNIs4xZFrDWKWJo+sUkRS9Mn7lPEeib4xE5FrF2KWK3atjVtr2mvexSxNMt4vyKWZj1q+v02RSxNv79XEUvTJx5VxNL0if3zr6dHH71FEWtcEeuZ0Bc+poil1efY33iv3QyvB0t6WJptSLOP1hzTWnVe2KpjWqveW2naXrMNadpLs4/eP3b4P3bYoHlvpdkX7lbE2r+msO/akKbtNcv4iCJWq94Padp+uyLWFkWsVp3n7O8n9t18Yn8/se9s36r9RJz5Fz8n8LxyenrGLj3HJ6zZdbDOBSyefzZgzamDdQlgSfsZpP0VVpaU/043FfqHCH+uE/zsKD2nPpCVOwFlm8eu6z1Tz8c+N5T0J4GrLp/qM/55wAftg8/4DxK4piDOhlKpmg7j2oVrbRFYuxSx9ipibVXEWqOIda8i1iZFrD2KWJr20iyjFi+pn20VX92tiKXZtjV9Yqci1v7+a3//5bKMmrbfrIil6fcPKmJptu1WbY+afXSrjrWa9bhFEeuZMA49E8qoyUuzX23Fcdv+xvv2VvEvTXs9rIi1XRFLc27SqmPa/va478rYquP2M+E+TbOPxj1dT0e/f0ARq1XXOh5SxHLRR+P7ejYsKf+fbirk8rQWzZ9pJIKJevlcRHHdvJgAfWQjfo3rTwJXZT6Vdfy5wAft0wb2cfOcIz2aAHzOZ55gH+m5As4j55f/5meq8/TzWBl5ev6b8vNrp5czavaT9j3oQhm3gTaQHRnL5ArF/kK6byhfGO3LZUez/enRfGEskxnIZAfzA7nc2Eh+YHQgmxvL9mdHeoLaesc24KiO83HbAD7LctQmI59lzRXqqNFnWctK1XStNP7Sd3Uc9rWFnqDWtuhnvHyK9Rr788OkPxk49ftMVJ1x+6CfzRe4poS4WZAv6px+NzbPDU/W5q7P6ZdsHnVOfxyb23B3qZoO49qFa20RWJsUsbYrYt2viLVVEWuLItYaRay9ili7FLE0y7hZEUuzjDsUsR5QxHpQEUvTvzTbo6Z/afaFmrx2KmJp+v0zwSfuVcTS9K89iliaZdS0/T2KWJp+v1sRa38/8fToJzTL+IgiluZ8olVt/6gi1v421BjWuCLW/ja072yvee++RRGL3lXBNSQblpT/TzcXst2CXiXsynm8C5rHzuEFwj5Yn3eesA9pHns0HcJ7oT7vMVpLSzJs/i32L5cXPck3y59wn/Cchn+Du43F8/Tpg6qYXytj9jDcgGHY0A14iUBzzTGbToC+IJDXQEl/Erjq8qmugbYBH7QProG2C1xTEGfDhlI1Hca1C9eisLYrYu1RxNqsiLVLEeshRaytili7W5TXFkWsNYpYm1qU115FLE2/1+Slafv7FbE061HT9vcoYmmW8VFFrLWKWI8pYmnaa6ciVqu2bc2xg+YT9I47nz/ODCbG8bnTDNDXweI4Ps1LuyB+SfnvdHMhQ/jT3eBXvl0xTbAxLxPpp3lmJ0ufCPmfsDCOdCUBS9t2UWXj/NF/pjE++I0LCWtag1jdQpyLOu2KKDfX3xPBVSpHB9ikQ9CTEGxC16dH8OLpewXdlJds2M3iFG2YjbIhb4ukfzLf/SC7LYJ055WqdkAfnBaCFcDfi+BaO8PjAe+5eR/ZE9T2maTX9o9UP4exePxmyGFMV7twDdsLz39YCJa01mDDWKkaz9P3ldcaLPblCydiLhL4RfnuYiH9IpaG+Ei2obw9gVxH0v+kJwjhlRI4tE+Rno4p0jN9ivR0T5GerinSg/37YkU9i1maTtBzuKKew1mamaDnCEU9R7A0OPc7ksXx/oZ4HCXwoPHpaHZde4zn+ogv2oD0J4GrMp/KXOto4IP2wbHlGIFrSojD8e4YQc8xgh4J60jgcCTLN0X1l51s/R3phk9k/R0p2LXR+jsI7HqMk3Jk+4nXsUFtoLjjmG70heNZHG8rGNrhb14mO17NPbSKi+mQD/cx4tYb1NY3T4f1ElVXKSE/pesOam2iWB+DaNdAKP8JTPcC9huDZHPibW1+XAM253Y9AeJ4vZ8IcdxvT4K4Y1ncyeXfvUG4zyUgjsqI17Aeef7jIvQc1aSeowQ9PUK+ZsfeqPZ4pKIebrejQM9Rinq43Y4BPcco6uG+eCzoOZTl489vdx1UzcPz8XsqnpfOiOyE9McvrGLuKWNSX8Lbs2JfMkxlOzGoDRR3EtONPnsyi0M/O4XFoW+cyuK4zTFI/RPZwvZPFzTQP/FxCPuZqPmKo/ld7PkK6Z+q+cpRwCdsDJT6b8ortSfaE9Ir2BX7b4mDNOedbD/kds4Uv25J/1TdSxwT067SvO4YsDmPo31KvUG4T0RxiLrPkPp+6jup3X+A7X15z0ETy8D7XnrXE+eJNlwMcccKcRb/sYMnlof6ow5Wnm6WF/t7Sv8l6ONPZOXUq/u+fuzHSQfXfbIj3XHbAemXxhXinRTiOprgOjYykM6l+/pGi3354UJ+LAH4xBWv4frlKUJ66fu+ZOtT3dg6S22hvVTFP4XZ1YYOFncyxHWyOOJox9hvLZzI/xRH/OPYn+tPCekvYWVopC5dYvH+QANr2iSxZgcT2xPvc9z2QdVzFngfREFq8ymI4z53AMTx9jQb4tIsjj/zwSDNM8kWtg0MNzDP5HP1k0MwaSzg9/A0xnRC2u+zse27MLbxcfPy0sQ4Pj6THovxO7hfIT38mSONkzbcGsLrv2D84n6l5zv5UfQP0sF1n+JId9zxi/ezyId4J4W4Zsav4cxYrpgeHs5nh0cLfX19UeMRv4bj16lCeunserJ12o2th6Xx61RmVxs6WByObXz8Io7S+OVm/M0Px7E/158S0i9lZWikLqlvl+ZNUl/x0tLEOL72xOe6v4M27maemC1iu+FB6udxfOA+ieNDhsXh+JBlcY2OD2SLRscH3k/yMnHMDnZN6uM7IX1n+QbMlqF9/kR9fEwn3Tbddkh3isDbbZuJ/8yN9Et9qIv7ZKlPlNqd5H/Yvnkc3yvE47ietKBHwqK6dFtHuXSPwCuA8vM2huuAvI3xesMgtTF+HzJ3km2MuPUKHHi6RvrblJCf0lF98HIr1keOypgLagPF5ZnuRp//EO9Gn/9wu+YhjvtmAeK4T/dBHPer/vLv3iDar3gclRGvYT3y/NkIPac2qedUQU+PkC8R8j/pwWuoR7JNVD8/WT3SvAbrXEMPt1sa9KQV9XBfzIAefv/Bn//0z6/m4fn48x9pXaET0s9jz39OK2N2B7XtYF/2JeizBRaHftbH4tA3+lkctzkGqX8iWzT6/IfPXXmZOPe48y5Kfz7Uk6N5Uno2lEuy6f75m/v5G19Twb6n0fkb+WOrzd/w+dm+mL/xtho1f+PpsI7jzN+kdeX987f987cwPfvnb5PT0wrzN/7sgc/f1saYv/G8YfO3djZ/2wDzAjfrZn7O3/i62QWTvKfH/qneGlcCdIfN864sPfU/rq/tYutrO+aH8zqR6Z69YGK6/fMzv9bX8Nno/vU1ub1Fzc94OqzjOPMznn///Kwat39+JuvZPz+bnJ5WXl/7lNL62q8OqWJ+Zv/62pOhVdbXcN5F6b/SQutr0nsGbvefxJ+/kf4kcFXmk8H6JD5oH5y/nSpwlfoeXF+T5omnCnokLFxfa5W9C7i+xttno+9C8HupRuZv3M7ETdq7jfXR6N5taf+4231EuQzObQKh/Hz8bnT+xvcWNTJ/43bFfp77Zg7iGp339QbRfsXjqIx4Leq9qHSEnpOb1HOyoMf1PGSq3ic7GfScrKhHWsee6vkof4eMz9/aF1Tz8Hx8/sbz4vyN0n+Pzd+6yphu9y033pegz+ZYHPoZnyOhb0jzvrj9E9+3fMEkxwTsn6R3AKU1LukdVrd1FP9bkqQ/KZTXxRzpROCD9qG2Zc/goDNtbiyuvuz24aU3j1xYXLPqOctGLxtaufrmoaXPGR1dWVy1ipeGa+gRSovegmno92zhOsc4uU4pzis99X9vUFvLcZ7OcaxzAUvq1bAXCcO6BLCkngtHJKm14ayTp+d80nX4XFYK55MGrEwdrOWAJd1VE1a2DtYKwOL5s5AvF6KHp+G9YU7QLeGj3+brcL6tNJEz54V3noU6WCsBi+cvAFZfHaxVgMXz90G+/hA9PA2/w+9nehLCNYnP6lI4n37AGqiDdTtg8fwDgDVYB+sOwOL5ByHfaSF6eJpBdv00pichXJP43FkK50N544xwnKviiBL7LRTSP1UjXD274irA6QLXlBCHTw1OF/ScLuiRsE5WxDpVEesURay0IlZWESuniJVXxOpTxCooYvUrYlGfKD1lmQN6Gn3KwvNP1VOWOaCH36Xzu82XwN0m+SC/2+R5aSzqhPRfYHebI2VM6USgqKdZuHrWqJ0lPTTWcB9WvOOtnC7Fx3AKFMfHuUPYbwzS3SnxbnT1jNsVx2Tez5wOcbzfOAPieNs9s/y7N6i1L/aJ0jyQX4vy474IPbkm9eQEPT1CvmbbpWQb1+0fV0Vzinqk+wf0Hw090r1Fvf5sK/RnlC+sP6O5bCek/xjrz+6F1TPeDvZlX4I+K81LKO4MFoe+cSaL4zbHIPVPZItmVs+wf5LaRHdQ63v74skh6U8GtW3OxT2DtCYgjYFS/015pfaEY620hpAX9EhYA8Ah6p7PUf1lJ1t/ru/5pPqLuueLW38Lwa55J+XIFXDs5wHHSl42aWcFrl8FYBseeJkafVorjevSXBTnD42eTsnzUzrH881+tGsglJ+vxzT6tHay801uV+wPeL0PQhz3WxwH+DhLY5s0D8S+rNF5IM8fNd90Ma91Pd+cqlNTp2pe22rzzS80ON/Ep7WU/i1svvlFmG/y9tyq8030Mz7fRN9oZr5Jtmh0vsnHodMYPvoXT8frUPL1QLiWEHCwzeVD9Ntwbemp/6X1kbmgo9H1kbkC3zhzbjdjWfw5N+mfqjl3X0y7Sr7VBzaX/AB9hOvpF/RIWNgPRs253cwN0/m49Uf6p2rOLd3LzBXsOhX+HVbP2Qg+bvr76hel6j1vJD72ZKiuoNaHpOesyJs/l6RrYXUTtT9CGvuj2mnU/oiwMoTVUdT+CMkGnRA3t3zyrbXh/y2YmIae689kaf4Iu4N4PWGbdvTsNHabxmeng274RD475fbhPjstiPYdXndh+0oyQlnRl9N1OKEvN7qHhWOhLze6h4VjoS9Le0yk+zrcKSm9NSHdgxK+9fHUweH42Qj8fAR+XwS+tDtbWifohzh+7znA8OdH4J8SgZ+OwM8I+IhJ/cZsFoene1PaQ8oYdo78vUNlvoRhg+O3MmL3Ka3+Voa07y3qTdiofqLRU080sGg/huM3CvqkNQ0KUtueqjcKeL1ge+d2xvUr3i5w/YrvcaFxQuqjm/UJnv/p9kYBfuHoREU90v5arHMNPa3wRgGfr/I1qrPhCwzSGwXSXBffKHiMrVGdV8Z0/La/6hsF6Geu3ijgpwQ0+0aB3e1OX667sbj6wuKaq4eW3jw6tPrm5cuuKN52e3HV6g6AxeaDbn5KCF2OE0TQtaEN4o6DeDoUuS2QQ5xlCzfDU/xlJ9I/VcsW9bbE43QkI3BNCXF4aKt0q5ER9EhY+PIjx54Hek4S9JwUoWeewLnVDhOZB3Fh29cw1OsmtA7r5Ryw3ht9vCm9xPRMPUyE23WqDxNxsS3y6XKYyFQ93ny6HyYS9nhzG0wd+QdZ4jzepPRb2dTxPpg6OnoZVfUwEfQzV4eJTPZlVL5Ugv0T/6AbfZyG4vgHefEjtPxjsoTPP+gmjTn08fde+Nv+Xlz+3Qm83gX+sJjlUfSHyodxqJykg+t25IuxX0kKuxXmvJNCXDMfxskWh0f6hobGciNj6ZGhsSK2deKK19qYfj5f4OlnCekdH/I4RO2FfxiHf9zFhg4Wh68Fd7I44ih9GMfNB5xyQ3Hsz/WnhPTnsTI0UpfSsgnOP+JizQ4m+i1v21LfhG1xMbu+L+7/SH8SuCrzqdz/LQ5q7XqoYFdpTkp5pbkL74N5HNcTdR/AsWi8kPr3I0HPIkHPogg9Rwqc3fpCdkgaEyhIffCREMf7AO4fGKSxfnH5d6P3f9zmxK1X4ID1fijwCfOvlJCf0rXaB7Ybvf/jH8Nu5P6P2xU/FLaYxeEyIvdpXBaW7i96g1r7ct3oq+3CNaxHnv+ECD2Lm9SzWNATNeeK0w9LeiTbRI0nk9XD7bYY9CxW1LOYpcH+5UhFPdwX8X4m7P7vR3D/R/ni3v9R+pXs/u+nMN93s67aeF+CPsvnp+hn/JHAYojj9/Pc5hik/ols0cz9H/ZP++dYk59jHSlwldrT8ew3ttt24VpU26S67A1q6wg/Dr9Y0LM4Qs9RQnm6BQ77co6FBz42M8eiMjU6x1rM4qLmWDwd+lKcORbPj3MsR/1iw/XR6ByL92GTnWPhOgj3TezfuE/j/EvaniWtW+Ecq9F7JJ7/uAg9RzapJ2oMd7X2PVVzrKma+2D/cpSiHu6LeIAhv/flc6xjDqnm4fn4HIvnxTkWpX8xm2MdX/7davfP6LNS3y7Nv9A3+PyL2xxDvfvuC5q870bunULawyCO0vax+rqh/FsaYw4PJsYdxuKOgDjpnl2aR3AMroP7HKW3Yaw0sQyU/swyb2vLGYfKmG0hmOTH0notX/+xoYPF6fnvSMby/snCKg9u0yfLW5pYJmlex9PjmvhRQnreF5GNpP4D55TSetrh7Bqt+Ur2JI77wp6cYxx78vSN2pNsJNnzaMA6QsDiNo6yJ3HcF/bkHOPYU1pzjWtPspFkz2MB63ABazG7hs8kCLtLSI99Ek9/Hetznr1wIj9p/ZPiDhOwed+bAAxejqRQjh6I43kt7pfnTeRP4/QQ6/eXg25pzW0xu4b1Jz2L4etj+DyWz4fxg02tsqaLc4S46zA4R3D1EQG+hvyDGPMHqZ6lDwOE9T08juflc0dcb1vNfGwT6D6xju44z3VPFPhE7UFz+3w9O9IjcKUg+RGu9XE/Qh/jfrQY4rgfof/x/V2N7g3k+0Di+hjWs3Rvyf0OfUx6VYqvAeOenm3Mxx4G3ScLuqW9n5ReehWH1xf6WNSHzhztK2ip/UQUx1+D4zbBIPkY39sQ18cejtGXxPUx/vFH3GeWqYOL/iPtVZTaH/mPtFfR8cetstJeSAroW1Jd5wXbSb6Fa2DS666Sb3GbYJD8h3/4Ko7/JEAP4WJfhT4jPSflr7XgUSpvY/3Sh8Ffpde8eXtGv5KO+eY2w35Jem20W8in6FcDPQJXChTHX8/Gfcj8VXLsl+IeKYh7Ds9kcXhcOw+SX5GdGumXsJ6lY+zj9ksFhovH+9Q7JgD9RzpqIa7/UF7H/tNSx05S3LNYnGv/0faZrXD8Me/T8ZigfEydlL7ekRfof5K/8vEgyv/weG3Kx9cIOX88SpXSf43dr1/O1jKe5FSq6iA7uV1TSRelNRVu187SxHJH2dCGRts82SwV1PbNBYiLOjJO2vPNj/TG1ze/z8bFX0J/We8TKo3Ot/CZqe/zLXyW48N8S6pnae4l7RuWnt3wuVd7yHE2v2E+RmeUku5cHd3oY1LfyOuL7C4dY0J53R47m8v3CFwpSL6C42OjviLd96Hf8v4EPzvEg+RjZKdGfAzrWepL+HoA+tjJAl/+IWP0sc6F1TRzYvgY192oj9GaxX4fmxg31T42J4aP8fUl9DHpnVmLuzbEx+YzHzsmho9FrW3t78eqca3sY8c46sf6wcfoudmJzMcGQffxgu6j2TX0Mem5EX9+jHsB+LM7ytst5GvVvSJHQhy3PT7r4Wv7OI/jczBuEwySj5GdGvExrOdjQQevKxvQxw4V+FrcXeUzQpKg1/7f1LuBo6PFTD7TPzhQzOdHBwuzAd8G8sUZDvTnC0P9I0P9mcxgPlPMZ+rqf3Kf55yJ9uxgeXg99gjXCJfaQifkXTLJcqBZE6AvCOT90aQ/CVyV+VT2R3cCH7QP7o/uErimhDiqg94gvE4SEMc5dAgcUkL+jhhYUnlmlsWGVauXryyeNbRi1e1LiwEE9JUE/N0Woj8h5A8isHgeF+1qpNA3PGIaV7qYedIfp7pdF0aHB9L92aHB0ZG+0VxhZKr1F4fzg/3DgyOF9Gh6MDOYa6Rf6QlqfSsR8r8N7RHYKQFrWemp/6kP4u1Isw8i/GnATwm/cnRXp2An0j3dSdnGxuL2r6Q/GTjt7yv963Tgg/bBd+S73dinaI/JJd/jfVaXYBvkMQ04Jh1xlNaIiRPFdbA44mHTHHzYRI5tjji6baNjo9Iche8dXw7zSaobvkbP/b6NxfP0q9m9yMry795g4rjE+6kZLH6aEE9/U321CWn5b/ybuKNdeXryya6QsnZBWSn92nL5LLdL5siY3H6cV1sI5gaGeTnUCd87GNXmKf0MIT1vY8SnN6htmzMgH+feHUwM/JpUPwlIi2MwjVM8X9jf3QJOGIfpAg6Ok4iJOqW5Ht5LtQt6eJviY363oF9xfChIYyUFaa6dgDhe9utL1XQYpPtYKpMt7/XwfI6nQz5SW9OcG9H1TnYd9eJ8vAvS8vEcbdapwDEl6OkC3GkR/BOA0yHk6wnk9ij9H5dvQuAbdT88WT0c6wWliXp4PfMx7fXQf/J+vF3Ie1epGs/Tv4WNaW+KOaZhX8LLcEOpeg37bJzHYpvE5/g4dmEaPo7z9E8IYxf2DxzLXntXjDmCNO/DOcKXmD3fC/aU5gC9Qa1t0Ie7QRefH9P4gjb4KOPxoYXhusiuPRFltNc+vlBOxznwdIghjZ2EIbVrytcr8MK2h31HV4QOaTyTdHRCXLP1I43bfK4hzWGkeD6ecz14rU1IX2/+kQzBlnC7BBypn58OcQkhDvswXl7eh+HcRLon432j1O7C6i5q7i1xjzOv6orgLtmP90PaaznpgXQmPdJfGBvLjPYNDefrreXQ9WmlieV68n92rZOVy4bpPD3EdbO4jtJE/cny3x1MD8ciHp2Q/l9ZXdvQxfJQ/pSgvwv0T+AtXOO+hljtwjVKb+v0O2WOLtbosoXBgaHB4XQmO5bN5gb66tWrZCe+dmAD2ZrXRZdQtk5I/zM25vwC5sidgj6b7g8R6RIh/z+JIVzrKE28JtUR911KT7qTpVqOFDeDxXWCnpnlv7m9OBbx6IT0vwff5f5G+VOC/umgfwJv4Rr67gwh/Qwhva2fX0N/xMuuvfb3pE7A59eQ2x8ctqu+fF9mYGBoYKRvZGwwPzI81WvvI4N9Y4O53HAmNzhaHMz0Tfnafz43PJYZM+v/ubF0biAz5c8+htJZ8yxzeLiQKQ4NDo5NefkzmcxYX354oG8ka5YYp/zZS36sf6hvrD9dyI7mi9nRoanWP9RfHMz35bIjubHBoYH0wFTrHx7tG0kP5jKjQ0P96f6+gUaePSWYfgrtQe38j+ZkNE9s9BlpWwRWIgKrsw7WuYDF81NeaX2gMu4FtfNwxb469qfK8Lm8m+cL0c/luX0m+1we16Kk+5QuQY+ElVDE6oDycOx6z2Wj/MbR/onYflOZwwRT4zftwKee30j7MqRn1PR9n6g+JGrPhmssqd/DNTvJNu0RerCubIizh8jVM4O4Pkf6p2oPUdw9N7gOz/PieosN6CdSnyg9V/MFi/dz0nOUW0oT46Q+UVo/ivJVWnfHvrQ3CK8b7N+lMZzzxXX5S8ubGKX9J4r+mMZ5FdfleB7RJ60lU+gRyo31ztcPsW5xTwiP43NV3HvGQzv8zW1hdZ98WBUX01GQfCQBcV1COaS1SxxrEgKvqP0qUWvg0jhB30FJAGYQRK9xSnPgevMRfB5og2Pfjz02kP5kUFtfLsaGemvJ6OtRewGk5xYJiON6pgt6JKw2Rax2RSx8rsbLjPPwhKAnEaEnam8Bz4f+62j+2hfXf0l/Mqi1iQv/bYtpV2mPRNSzcb6XBuPizE2fqVhR93xxfEjSg+2f6+HzG75nYRucfUn5+DN2nveyUjWep//CoVXM+8q/o+5legO5HXIuks+2RZRf0tMt5FtS/j/dWCjgBbd7gdODOG/iQZo34TOFAOzHA+fd6HnXfH6WhDg+p5oBcbyvnglxfD5BHCQfwbl8oz7C80f5YmeTejoFPa7bPK49udjnz8s2VfvRouajk9UjPeuX5g28r3wC+kppPxLPu7xUjefpP8b6ynfDPaWjNY5+ab9lAOWOe++Gfsb7IPSNGSyO2xyD1D9VnvkHjZ13zX2CysT3yElzWWn8pvTSnh9pDi/dH1LeVh0rpHrC+p3J4rB+e1gcttdZLA7f1eGh3tjUyFlI0n0aT4d7fhICR97Wo+6b6bo0H+wUdEZxlO4lo/yV2xP3xUl79qL6LM4/rM/6Wtke9c5CIjs5PgupTzoLidu1EzhF2dCGRts8rvtI/aM0RuNY0ylg8nm59jPc/uxIYShXGEyPFAvmaXZ/I89wo/Z9Ru2nxTqQ9orbgOuulP6nMEa6ebdMXncN21NI+4qw7eI3Lir2KK9L2rQ/g75FWsOQ7InzVckfpXdrsB4q+4aCQFzLwTJQ+l/H7AOoPI77gLzUB/B3dLAPiHo/yQbsA2YK6fk4iftopXEyEdSOB5LNcYzge2el/ofw8BnFH1kd4Rnz3K+TwF3qo6T7alzTlt5rslwWwHuMjtZnG57XJiCOtxOcE+H7oTxOmi8lBA7S3IZs0ejzCo1+gs/tnuRXquW1L9otH2+x3UrvIfL02G7rtXO6p0sFtXWJ/i2NBY20GRvOA33S/Iy3mRlMF+2zVK6DyjkeZOt2xrmjVOVO+qW95JSuco/jhmuauNL+WRq3uE5eljZIj79xv/pJh1V58zLyeozady7t3eV7momjtM97RqkxrOmANa0JLOIl7WeeNkleElYXYDWyT/8w1iakZ5Rh69ppVqe8bwtb18Y5D6U/j83bcuXfLp4f1+ursc+r2DKQx6ol5b/TzYXYz2NJfzKoHVddPM+SxgTpHprsM8MNn3zUXFEao+z5FbOC2jrj/AiLr9/ScxfJv/AepdH9izw/7kvgdRy1nwHHxjj7Gbi/zwii7y8TgCW1Y2mOJNlCWpvB+7WLWLsfgXYv7X+R2i+2e2n/C8WF7X8J8y3p2Tul7xHSS/cmpJv7Xk8MrKh1k1lC+p4I3ZwXz4u6w9pI1FkrjuexBWkey+eeOI+Nup+0IY4tpXpMQXpuO6kdY3vkemdAHG9/2Mal54C8vUhrXPy+lsbom8rX+HufQaA/dvD2p40/kC6MSueUKPLPuX1GlBl0vO83TX53dmkifgB62yEd5uH5zmFpzglJcy5Lc25ImvNYmvNC0pzP0pwfkuYCluaCkDTPY2meF5LmQpbmwpA0F7E0F4WkuZiluTgkzSUszSUhaS5laS4NSXMZS3NZSJrLWZrLQ9JcwdJcEZLmSpbmypA0V7E0V4WkeT5L8/yQNFezNFeHpLmGpbkmJM21LM21IWmuY2muC0lzPUtzfUiaF7A0L4A03UHtmKDXD+bzbvuRzMC+O/80M5gAfUEg3w+18vmnT6YpVfkkIK6jVFsOfBec16+dB53O0km+ZYPLvZdm/B1xPH5l9p3fPT3O3X0yTanKB+M6SrXlaNTvpP2ENt257Pf55d9u+8Gn5oOu/N2GOQJ/XJvk64PSuh3ZdV+dFXJO+e9WPiuEvunF1+XPKlXxNNsVrXMOE6fAab9S874lPQfAto3raY7e/8gRn6h1G66/2b2OXFcycDt+RJUt6j1R6Z3oKKy47yoT1r6sU2kvSAL+5unbhLJJY8s0iOtgcV0Qx8cW/i7Z6cBH2gOcEPhE8ZfqWVr3xPf9HO0bzEaN47w+SP9M9nu0OHz7jRctvzGAgGu2VM75kI760Lag1re7QrAC+Hs+XGtneDzwvrujNDH9kvL1dBOhf6D6nJL8kD+n5KGDxfP0ZEjtPV9j/UOZsdzQ2FBhaHQ0P1L33JL/D3mBSET25wYA",
            "debug_symbols": "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",
            "brillig_names": [
                "discover_new_messages",
                "debug_log_oracle_wrapper"
            ],
            "verification_key": "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"
        },
        {
            "name": "entrypoint",
            "is_unconstrained": false,
            "custom_attributes": [
                "private",
                "noinitcheck"
            ],
            "abi": {
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "kind": "struct",
                            "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
                            "fields": [
                                {
                                    "name": "call_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                        "fields": [
                                            {
                                                "name": "msg_sender",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "contract_address",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "function_selector",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "is_static_call",
                                                "type": {
                                                    "kind": "boolean"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "historical_header",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                        "fields": [
                                            {
                                                "name": "last_archive",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                    "fields": [
                                                        {
                                                            "name": "root",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "next_available_leaf_index",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content_commitment",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                    "fields": [
                                                        {
                                                            "name": "num_txs",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "blobs_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "in_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "out_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "state",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                    "fields": [
                                                        {
                                                            "name": "l1_to_l2_message_tree",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                "fields": [
                                                                    {
                                                                        "name": "root",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "next_available_leaf_index",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "partial",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                                "fields": [
                                                                    {
                                                                        "name": "note_hash_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "nullifier_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "public_data_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "global_variables",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                    "fields": [
                                                        {
                                                            "name": "chain_id",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "version",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "block_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "slot_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "timestamp",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 64
                                                            }
                                                        },
                                                        {
                                                            "name": "coinbase",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "fee_recipient",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "gas_fees",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "total_fees",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "total_mana_used",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "tx_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                        "fields": [
                                            {
                                                "name": "chain_id",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "version",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "gas_settings",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                    "fields": [
                                                        {
                                                            "name": "gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "teardown_gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_priority_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "start_side_effect_counter",
                                    "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                    }
                                }
                            ]
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "app_payload",
                        "type": {
                            "kind": "struct",
                            "path": "authwit::entrypoint::app::AppPayload",
                            "fields": [
                                {
                                    "name": "function_calls",
                                    "type": {
                                        "kind": "array",
                                        "length": 4,
                                        "type": {
                                            "kind": "struct",
                                            "path": "authwit::entrypoint::function_call::FunctionCall",
                                            "fields": [
                                                {
                                                    "name": "args_hash",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                },
                                                {
                                                    "name": "function_selector",
                                                    "type": {
                                                        "kind": "struct",
                                                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                        "fields": [
                                                            {
                                                                "name": "inner",
                                                                "type": {
                                                                    "kind": "integer",
                                                                    "sign": "unsigned",
                                                                    "width": 32
                                                                }
                                                            }
                                                        ]
                                                    }
                                                },
                                                {
                                                    "name": "target_address",
                                                    "type": {
                                                        "kind": "struct",
                                                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                        "fields": [
                                                            {
                                                                "name": "inner",
                                                                "type": {
                                                                    "kind": "field"
                                                                }
                                                            }
                                                        ]
                                                    }
                                                },
                                                {
                                                    "name": "is_public",
                                                    "type": {
                                                        "kind": "boolean"
                                                    }
                                                },
                                                {
                                                    "name": "is_static",
                                                    "type": {
                                                        "kind": "boolean"
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                },
                                {
                                    "name": "nonce",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ]
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "fee_payload",
                        "type": {
                            "kind": "struct",
                            "path": "authwit::entrypoint::fee::FeePayload",
                            "fields": [
                                {
                                    "name": "function_calls",
                                    "type": {
                                        "kind": "array",
                                        "length": 2,
                                        "type": {
                                            "kind": "struct",
                                            "path": "authwit::entrypoint::function_call::FunctionCall",
                                            "fields": [
                                                {
                                                    "name": "args_hash",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                },
                                                {
                                                    "name": "function_selector",
                                                    "type": {
                                                        "kind": "struct",
                                                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                        "fields": [
                                                            {
                                                                "name": "inner",
                                                                "type": {
                                                                    "kind": "integer",
                                                                    "sign": "unsigned",
                                                                    "width": 32
                                                                }
                                                            }
                                                        ]
                                                    }
                                                },
                                                {
                                                    "name": "target_address",
                                                    "type": {
                                                        "kind": "struct",
                                                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                        "fields": [
                                                            {
                                                                "name": "inner",
                                                                "type": {
                                                                    "kind": "field"
                                                                }
                                                            }
                                                        ]
                                                    }
                                                },
                                                {
                                                    "name": "is_public",
                                                    "type": {
                                                        "kind": "boolean"
                                                    }
                                                },
                                                {
                                                    "name": "is_static",
                                                    "type": {
                                                        "kind": "boolean"
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                },
                                {
                                    "name": "nonce",
                                    "type": {
                                        "kind": "field"
                                    }
                                },
                                {
                                    "name": "is_fee_payer",
                                    "type": {
                                        "kind": "boolean"
                                    }
                                }
                            ]
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "cancellable",
                        "type": {
                            "kind": "boolean"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
                        "fields": [
                            {
                                "name": "call_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "function_selector",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "args_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "returns_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "min_revertible_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "is_fee_payer",
                                "type": {
                                    "kind": "boolean"
                                }
                            },
                            {
                                "name": "max_block_number",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                                    "fields": [
                                        {
                                            "name": "_opt",
                                            "type": {
                                                "kind": "struct",
                                                "path": "std::option::Option",
                                                "fields": [
                                                    {
                                                        "name": "_is_some",
                                                        "type": {
                                                            "kind": "boolean"
                                                        }
                                                    },
                                                    {
                                                        "name": "_value",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "note_hash_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifier_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "key_validation_requests_and_generators",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                                        "fields": [
                                            {
                                                "name": "request",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                                    "fields": [
                                                        {
                                                            "name": "pk_m",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                                                "fields": [
                                                                    {
                                                                        "name": "x",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "y",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "is_infinite",
                                                                        "type": {
                                                                            "kind": "boolean"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "sk_app",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "sk_app_generator",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "note_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifiers",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "note_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 5,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                                        "fields": [
                                            {
                                                "name": "call_context",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "function_selector",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "args_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "returns_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "start_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "end_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                                        "fields": [
                                            {
                                                "name": "inner",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        },
                                                        {
                                                            "name": "calldata_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_teardown_call_request",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        },
                                        {
                                            "name": "calldata_hash",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "l2_to_l1_msgs",
                                "type": {
                                    "kind": "array",
                                    "length": 2,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                        "fields": [
                                            {
                                                "name": "recipient",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_logs",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                                        "fields": [
                                            {
                                                "name": "log",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::log::Log",
                                                    "fields": [
                                                        {
                                                            "name": "fields",
                                                            "type": {
                                                                "kind": "array",
                                                                "length": 18,
                                                                "type": {
                                                                    "kind": "field"
                                                                }
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "note_hash_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "contract_class_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 1,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "start_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "end_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "historical_header",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                    "fields": [
                                        {
                                            "name": "last_archive",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                "fields": [
                                                    {
                                                        "name": "root",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "next_available_leaf_index",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "content_commitment",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                "fields": [
                                                    {
                                                        "name": "num_txs",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "blobs_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "in_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "out_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "state",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                "fields": [
                                                    {
                                                        "name": "l1_to_l2_message_tree",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                            "fields": [
                                                                {
                                                                    "name": "root",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "next_available_leaf_index",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "partial",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                            "fields": [
                                                                {
                                                                    "name": "note_hash_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "nullifier_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "public_data_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "global_variables",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                "fields": [
                                                    {
                                                        "name": "chain_id",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "version",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "block_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "slot_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "timestamp",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 64
                                                        }
                                                    },
                                                    {
                                                        "name": "coinbase",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "fee_recipient",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "gas_fees",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "total_fees",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "total_mana_used",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "tx_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                    "fields": [
                                        {
                                            "name": "chain_id",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "version",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "gas_settings",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                "fields": [
                                                    {
                                                        "name": "gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "teardown_gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_priority_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    },
                    "visibility": "databus"
                },
                "error_types": {
                    "576755928210959028": {
                        "error_kind": "string",
                        "string": "0 has a square root; you cannot claim it is not square"
                    },
                    "2709101749560550278": {
                        "error_kind": "string",
                        "string": "Cannot serialize point at infinity as bytes."
                    },
                    "2896122431943215824": {
                        "error_kind": "fmtstring",
                        "length": 144,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "2920182694213909827": {
                        "error_kind": "string",
                        "string": "attempt to subtract with overflow"
                    },
                    "3305101268118424981": {
                        "error_kind": "string",
                        "string": "Attempted to delete past the length of a CapsuleArray"
                    },
                    "3367683922240523006": {
                        "error_kind": "fmtstring",
                        "length": 58,
                        "item_types": [
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "5019202896831570965": {
                        "error_kind": "string",
                        "string": "attempt to add with overflow"
                    },
                    "5727012404371710682": {
                        "error_kind": "string",
                        "string": "push out of bounds"
                    },
                    "5870202753060865374": {
                        "error_kind": "fmtstring",
                        "length": 61,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "6336853191198150230": {
                        "error_kind": "fmtstring",
                        "length": 77,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "6485997221020871071": {
                        "error_kind": "string",
                        "string": "call to assert_max_bit_size"
                    },
                    "6753155520859132764": {
                        "error_kind": "string",
                        "string": "Failed to deliver note"
                    },
                    "7233212735005103307": {
                        "error_kind": "string",
                        "string": "attempt to multiply with overflow"
                    },
                    "8270195893599566439": {
                        "error_kind": "string",
                        "string": "Invalid public keys hint for address"
                    },
                    "8830323656616886390": {
                        "error_kind": "string",
                        "string": "Got a public log emitted by a different contract"
                    },
                    "12099279057757775880": {
                        "error_kind": "string",
                        "string": "DST_LEN too large for offset"
                    },
                    "12822839658937144934": {
                        "error_kind": "fmtstring",
                        "length": 75,
                        "item_types": []
                    },
                    "13649294680379557736": {
                        "error_kind": "string",
                        "string": "extend_from_bounded_vec out of bounds"
                    },
                    "14225679739041873922": {
                        "error_kind": "string",
                        "string": "Index out of bounds"
                    },
                    "14514982005979867414": {
                        "error_kind": "string",
                        "string": "attempt to bit-shift with overflow"
                    },
                    "14657895983200220173": {
                        "error_kind": "string",
                        "string": "Attempted to read past the length of a CapsuleArray"
                    },
                    "15366650908120444287": {
                        "error_kind": "fmtstring",
                        "length": 48,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "16218014537381711836": {
                        "error_kind": "string",
                        "string": "Value does not fit in field"
                    },
                    "16446004518090376065": {
                        "error_kind": "string",
                        "string": "Input length must be a multiple of 32"
                    },
                    "16954218183513903507": {
                        "error_kind": "string",
                        "string": "Attempted to read past end of BoundedVec"
                    },
                    "17843811134343075018": {
                        "error_kind": "string",
                        "string": "Stack too deep"
                    },
                    "17879506016437779469": {
                        "error_kind": "fmtstring",
                        "length": 128,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "18194595712952743247": {
                        "error_kind": "fmtstring",
                        "length": 98,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    }
                }
            },
            "bytecode": "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",
            "debug_symbols": "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VD1qKelRS0mPWkp61FLSo5ayHrWU9ailrEctZT1qqfvM7YGh6lFLWY9aynrUUtajlrIetVT0qKWiRy0VPWqp6FFL3WduDwxVj1oqetRS0aOWih61VNSopWzUqKVs1KilbNSopWzUqKVsSE+oatRSNmrUUjZq1FI2atRSNnrUktWjlqwetWT1qCWrRy11n7k9MFQ9asnqUUtWj1qyetSS1aOWnB615PSoJadHLTk9aqn7zO2BoepRS06PWnJ61JLTo5acHrXk9aglr0cteT1qyetRS91nbg8MVY9a8nrUktejlrweteSnVksphrxdnWIOz6H+Xj5NrYDqy59a1dSXP7VSqS9/avVRXz7JXv7UKqG+/Kl3/vryp97N68ufeoeuL1/2rjv3nOf68mXvunPPY64vX/auO/fc5PryZe+6c883ri9f9q479xzi+vJl77pzzwuuL1/2rjv3XN/68mXvunPP360vX/auO/ec3PryZe+6c8+zrS9f9q4799zZ+vJl77pzz4etL1/2rjv3HNf68mXvunPPW60vX/auO/dc1PryZe+6c88vrS+fYdct8XHYKdH58rOz2ytn9+uKr4tdPvpKQCq0XZ1K8ZWrfdowkn8swx2t2SXarnUpVC7+NQlnz4+NlYvN/srWPJ0nerv4DtwBeF/gf65snNn/im4XV/5AQwlbdkLJ+fkv7vBPf4+0mMd3XmzY/j6p7+rj7Yqvi6M17nz1zlLYPoxu/z76eAmylx9lLz/JXn6Wvfwidvm3//hv//ZP//zP//Q//+s//+t//4f/+Kd//Zd//3Wz+fV/7JvfGBVjv17Qm/j40La3j7VfPN78XKd2V2q6KzfdVVruevPThtpdtuku13SXb7qLmu5qqg3fVBu+qTZ8U234ptqgptqgptqgptqgptqgptqgptqgptqgptqgptqgptoITbURmmojNNVGaKqN0FQboak2QlNthKbaCE21EZpqIzbVRmyqjdhUG7GpNmJTbcSm2ohNtRGbaiM21UZsqo3UVBupqTZSU22kptpITbWRmmojNdVGaqqN1FQbqak2clNt5KbayE21kZtqIzfVRm6qjdxUG8dW25vdZHlTnto7dmtONd1VWu46Pjqiepdtuss13XVYG/7W4Nvucq58u+ugoRbi3h6P1j1dTQdXU95bdf4pp+Ge0+MB/h+uJ+8/avs1Caqy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",
            "brillig_names": [
                "discover_new_messages",
                "notify_enqueued_public_function_call_wrapper",
                "call_private_function_internal",
                "debug_log_oracle_wrapper",
                "notify_set_min_revertible_side_effect_counter_oracle_wrapper",
                "notify_created_nullifier_oracle_wrapper",
                "directive_invert",
                "directive_integer_quotient"
            ],
            "verification_key": "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"
        },
        {
            "name": "get_accepted_asset",
            "is_unconstrained": false,
            "custom_attributes": [
                "private"
            ],
            "abi": {
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "kind": "struct",
                            "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
                            "fields": [
                                {
                                    "name": "call_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                        "fields": [
                                            {
                                                "name": "msg_sender",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "contract_address",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "function_selector",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "is_static_call",
                                                "type": {
                                                    "kind": "boolean"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "historical_header",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                        "fields": [
                                            {
                                                "name": "last_archive",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                    "fields": [
                                                        {
                                                            "name": "root",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "next_available_leaf_index",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content_commitment",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                    "fields": [
                                                        {
                                                            "name": "num_txs",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "blobs_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "in_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "out_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "state",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                    "fields": [
                                                        {
                                                            "name": "l1_to_l2_message_tree",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                "fields": [
                                                                    {
                                                                        "name": "root",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "next_available_leaf_index",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "partial",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                                "fields": [
                                                                    {
                                                                        "name": "note_hash_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "nullifier_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "public_data_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "global_variables",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                    "fields": [
                                                        {
                                                            "name": "chain_id",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "version",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "block_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "slot_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "timestamp",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 64
                                                            }
                                                        },
                                                        {
                                                            "name": "coinbase",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "fee_recipient",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "gas_fees",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "total_fees",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "total_mana_used",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "tx_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                        "fields": [
                                            {
                                                "name": "chain_id",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "version",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "gas_settings",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                    "fields": [
                                                        {
                                                            "name": "gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "teardown_gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_priority_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "start_side_effect_counter",
                                    "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                    }
                                }
                            ]
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
                        "fields": [
                            {
                                "name": "call_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "function_selector",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "args_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "returns_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "min_revertible_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "is_fee_payer",
                                "type": {
                                    "kind": "boolean"
                                }
                            },
                            {
                                "name": "max_block_number",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                                    "fields": [
                                        {
                                            "name": "_opt",
                                            "type": {
                                                "kind": "struct",
                                                "path": "std::option::Option",
                                                "fields": [
                                                    {
                                                        "name": "_is_some",
                                                        "type": {
                                                            "kind": "boolean"
                                                        }
                                                    },
                                                    {
                                                        "name": "_value",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "note_hash_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifier_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "key_validation_requests_and_generators",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                                        "fields": [
                                            {
                                                "name": "request",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                                    "fields": [
                                                        {
                                                            "name": "pk_m",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                                                "fields": [
                                                                    {
                                                                        "name": "x",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "y",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "is_infinite",
                                                                        "type": {
                                                                            "kind": "boolean"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "sk_app",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "sk_app_generator",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "note_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifiers",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "note_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 5,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                                        "fields": [
                                            {
                                                "name": "call_context",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "function_selector",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "args_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "returns_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "start_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "end_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                                        "fields": [
                                            {
                                                "name": "inner",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        },
                                                        {
                                                            "name": "calldata_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_teardown_call_request",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        },
                                        {
                                            "name": "calldata_hash",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "l2_to_l1_msgs",
                                "type": {
                                    "kind": "array",
                                    "length": 2,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                        "fields": [
                                            {
                                                "name": "recipient",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_logs",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                                        "fields": [
                                            {
                                                "name": "log",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::log::Log",
                                                    "fields": [
                                                        {
                                                            "name": "fields",
                                                            "type": {
                                                                "kind": "array",
                                                                "length": 18,
                                                                "type": {
                                                                    "kind": "field"
                                                                }
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "note_hash_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "contract_class_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 1,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "start_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "end_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "historical_header",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                    "fields": [
                                        {
                                            "name": "last_archive",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                "fields": [
                                                    {
                                                        "name": "root",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "next_available_leaf_index",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "content_commitment",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                "fields": [
                                                    {
                                                        "name": "num_txs",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "blobs_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "in_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "out_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "state",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                "fields": [
                                                    {
                                                        "name": "l1_to_l2_message_tree",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                            "fields": [
                                                                {
                                                                    "name": "root",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "next_available_leaf_index",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "partial",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                            "fields": [
                                                                {
                                                                    "name": "note_hash_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "nullifier_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "public_data_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "global_variables",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                "fields": [
                                                    {
                                                        "name": "chain_id",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "version",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "block_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "slot_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "timestamp",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 64
                                                        }
                                                    },
                                                    {
                                                        "name": "coinbase",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "fee_recipient",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "gas_fees",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "total_fees",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "total_mana_used",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "tx_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                    "fields": [
                                        {
                                            "name": "chain_id",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "version",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "gas_settings",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                "fields": [
                                                    {
                                                        "name": "gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "teardown_gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_priority_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    },
                    "visibility": "databus"
                },
                "error_types": {
                    "576755928210959028": {
                        "error_kind": "string",
                        "string": "0 has a square root; you cannot claim it is not square"
                    },
                    "2709101749560550278": {
                        "error_kind": "string",
                        "string": "Cannot serialize point at infinity as bytes."
                    },
                    "2896122431943215824": {
                        "error_kind": "fmtstring",
                        "length": 144,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "2920182694213909827": {
                        "error_kind": "string",
                        "string": "attempt to subtract with overflow"
                    },
                    "3305101268118424981": {
                        "error_kind": "string",
                        "string": "Attempted to delete past the length of a CapsuleArray"
                    },
                    "3367683922240523006": {
                        "error_kind": "fmtstring",
                        "length": 58,
                        "item_types": [
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "5019202896831570965": {
                        "error_kind": "string",
                        "string": "attempt to add with overflow"
                    },
                    "5727012404371710682": {
                        "error_kind": "string",
                        "string": "push out of bounds"
                    },
                    "5870202753060865374": {
                        "error_kind": "fmtstring",
                        "length": 61,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "6336853191198150230": {
                        "error_kind": "fmtstring",
                        "length": 77,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "6485997221020871071": {
                        "error_kind": "string",
                        "string": "call to assert_max_bit_size"
                    },
                    "6753155520859132764": {
                        "error_kind": "string",
                        "string": "Failed to deliver note"
                    },
                    "7233212735005103307": {
                        "error_kind": "string",
                        "string": "attempt to multiply with overflow"
                    },
                    "8270195893599566439": {
                        "error_kind": "string",
                        "string": "Invalid public keys hint for address"
                    },
                    "8830323656616886390": {
                        "error_kind": "string",
                        "string": "Got a public log emitted by a different contract"
                    },
                    "12099279057757775880": {
                        "error_kind": "string",
                        "string": "DST_LEN too large for offset"
                    },
                    "12822839658937144934": {
                        "error_kind": "fmtstring",
                        "length": 75,
                        "item_types": []
                    },
                    "13649294680379557736": {
                        "error_kind": "string",
                        "string": "extend_from_bounded_vec out of bounds"
                    },
                    "14225679739041873922": {
                        "error_kind": "string",
                        "string": "Index out of bounds"
                    },
                    "14514982005979867414": {
                        "error_kind": "string",
                        "string": "attempt to bit-shift with overflow"
                    },
                    "14657895983200220173": {
                        "error_kind": "string",
                        "string": "Attempted to read past the length of a CapsuleArray"
                    },
                    "15366650908120444287": {
                        "error_kind": "fmtstring",
                        "length": 48,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "16218014537381711836": {
                        "error_kind": "string",
                        "string": "Value does not fit in field"
                    },
                    "16446004518090376065": {
                        "error_kind": "string",
                        "string": "Input length must be a multiple of 32"
                    },
                    "16954218183513903507": {
                        "error_kind": "string",
                        "string": "Attempted to read past end of BoundedVec"
                    },
                    "17843811134343075018": {
                        "error_kind": "string",
                        "string": "Stack too deep"
                    },
                    "17879506016437779469": {
                        "error_kind": "fmtstring",
                        "length": 128,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "18194595712952743247": {
                        "error_kind": "fmtstring",
                        "length": 98,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    }
                }
            },
            "bytecode": "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",
            "debug_symbols": "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",
            "brillig_names": [
                "discover_new_messages",
                "store_in_execution_cache_oracle_wrapper"
            ],
            "verification_key": "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"
        },
        {
            "name": "fee_entrypoint_public",
            "is_unconstrained": false,
            "custom_attributes": [
                "private"
            ],
            "abi": {
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "kind": "struct",
                            "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
                            "fields": [
                                {
                                    "name": "call_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                        "fields": [
                                            {
                                                "name": "msg_sender",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "contract_address",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "function_selector",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "is_static_call",
                                                "type": {
                                                    "kind": "boolean"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "historical_header",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                        "fields": [
                                            {
                                                "name": "last_archive",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                    "fields": [
                                                        {
                                                            "name": "root",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "next_available_leaf_index",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content_commitment",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                    "fields": [
                                                        {
                                                            "name": "num_txs",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "blobs_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "in_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "out_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "state",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                    "fields": [
                                                        {
                                                            "name": "l1_to_l2_message_tree",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                "fields": [
                                                                    {
                                                                        "name": "root",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "next_available_leaf_index",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "partial",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                                "fields": [
                                                                    {
                                                                        "name": "note_hash_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "nullifier_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "public_data_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "global_variables",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                    "fields": [
                                                        {
                                                            "name": "chain_id",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "version",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "block_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "slot_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "timestamp",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 64
                                                            }
                                                        },
                                                        {
                                                            "name": "coinbase",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "fee_recipient",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "gas_fees",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "total_fees",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "total_mana_used",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "tx_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                        "fields": [
                                            {
                                                "name": "chain_id",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "version",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "gas_settings",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                    "fields": [
                                                        {
                                                            "name": "gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "teardown_gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_priority_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "start_side_effect_counter",
                                    "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                    }
                                }
                            ]
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "max_fee",
                        "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "nonce",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
                        "fields": [
                            {
                                "name": "call_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "function_selector",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "args_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "returns_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "min_revertible_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "is_fee_payer",
                                "type": {
                                    "kind": "boolean"
                                }
                            },
                            {
                                "name": "max_block_number",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                                    "fields": [
                                        {
                                            "name": "_opt",
                                            "type": {
                                                "kind": "struct",
                                                "path": "std::option::Option",
                                                "fields": [
                                                    {
                                                        "name": "_is_some",
                                                        "type": {
                                                            "kind": "boolean"
                                                        }
                                                    },
                                                    {
                                                        "name": "_value",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "note_hash_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifier_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "key_validation_requests_and_generators",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                                        "fields": [
                                            {
                                                "name": "request",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                                    "fields": [
                                                        {
                                                            "name": "pk_m",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                                                "fields": [
                                                                    {
                                                                        "name": "x",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "y",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "is_infinite",
                                                                        "type": {
                                                                            "kind": "boolean"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "sk_app",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "sk_app_generator",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "note_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifiers",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "note_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 5,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                                        "fields": [
                                            {
                                                "name": "call_context",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "function_selector",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "args_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "returns_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "start_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "end_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                                        "fields": [
                                            {
                                                "name": "inner",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        },
                                                        {
                                                            "name": "calldata_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_teardown_call_request",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        },
                                        {
                                            "name": "calldata_hash",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "l2_to_l1_msgs",
                                "type": {
                                    "kind": "array",
                                    "length": 2,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                        "fields": [
                                            {
                                                "name": "recipient",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_logs",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                                        "fields": [
                                            {
                                                "name": "log",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::log::Log",
                                                    "fields": [
                                                        {
                                                            "name": "fields",
                                                            "type": {
                                                                "kind": "array",
                                                                "length": 18,
                                                                "type": {
                                                                    "kind": "field"
                                                                }
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "note_hash_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "contract_class_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 1,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "start_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "end_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "historical_header",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                    "fields": [
                                        {
                                            "name": "last_archive",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                "fields": [
                                                    {
                                                        "name": "root",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "next_available_leaf_index",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "content_commitment",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                "fields": [
                                                    {
                                                        "name": "num_txs",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "blobs_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "in_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "out_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "state",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                "fields": [
                                                    {
                                                        "name": "l1_to_l2_message_tree",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                            "fields": [
                                                                {
                                                                    "name": "root",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "next_available_leaf_index",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "partial",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                            "fields": [
                                                                {
                                                                    "name": "note_hash_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "nullifier_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "public_data_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "global_variables",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                "fields": [
                                                    {
                                                        "name": "chain_id",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "version",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "block_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "slot_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "timestamp",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 64
                                                        }
                                                    },
                                                    {
                                                        "name": "coinbase",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "fee_recipient",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "gas_fees",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "total_fees",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "total_mana_used",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "tx_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                    "fields": [
                                        {
                                            "name": "chain_id",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "version",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "gas_settings",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                "fields": [
                                                    {
                                                        "name": "gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "teardown_gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_priority_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    },
                    "visibility": "databus"
                },
                "error_types": {
                    "576755928210959028": {
                        "error_kind": "string",
                        "string": "0 has a square root; you cannot claim it is not square"
                    },
                    "2709101749560550278": {
                        "error_kind": "string",
                        "string": "Cannot serialize point at infinity as bytes."
                    },
                    "2896122431943215824": {
                        "error_kind": "fmtstring",
                        "length": 144,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "2920182694213909827": {
                        "error_kind": "string",
                        "string": "attempt to subtract with overflow"
                    },
                    "3305101268118424981": {
                        "error_kind": "string",
                        "string": "Attempted to delete past the length of a CapsuleArray"
                    },
                    "3367683922240523006": {
                        "error_kind": "fmtstring",
                        "length": 58,
                        "item_types": [
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "5019202896831570965": {
                        "error_kind": "string",
                        "string": "attempt to add with overflow"
                    },
                    "5727012404371710682": {
                        "error_kind": "string",
                        "string": "push out of bounds"
                    },
                    "5870202753060865374": {
                        "error_kind": "fmtstring",
                        "length": 61,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "6336853191198150230": {
                        "error_kind": "fmtstring",
                        "length": 77,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "6485997221020871071": {
                        "error_kind": "string",
                        "string": "call to assert_max_bit_size"
                    },
                    "6753155520859132764": {
                        "error_kind": "string",
                        "string": "Failed to deliver note"
                    },
                    "7233212735005103307": {
                        "error_kind": "string",
                        "string": "attempt to multiply with overflow"
                    },
                    "8270195893599566439": {
                        "error_kind": "string",
                        "string": "Invalid public keys hint for address"
                    },
                    "8830323656616886390": {
                        "error_kind": "string",
                        "string": "Got a public log emitted by a different contract"
                    },
                    "12099279057757775880": {
                        "error_kind": "string",
                        "string": "DST_LEN too large for offset"
                    },
                    "12822839658937144934": {
                        "error_kind": "fmtstring",
                        "length": 75,
                        "item_types": []
                    },
                    "13649294680379557736": {
                        "error_kind": "string",
                        "string": "extend_from_bounded_vec out of bounds"
                    },
                    "14225679739041873922": {
                        "error_kind": "string",
                        "string": "Index out of bounds"
                    },
                    "14514982005979867414": {
                        "error_kind": "string",
                        "string": "attempt to bit-shift with overflow"
                    },
                    "14657895983200220173": {
                        "error_kind": "string",
                        "string": "Attempted to read past the length of a CapsuleArray"
                    },
                    "15366650908120444287": {
                        "error_kind": "fmtstring",
                        "length": 48,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "16218014537381711836": {
                        "error_kind": "string",
                        "string": "Value does not fit in field"
                    },
                    "16446004518090376065": {
                        "error_kind": "string",
                        "string": "Input length must be a multiple of 32"
                    },
                    "16954218183513903507": {
                        "error_kind": "string",
                        "string": "Attempted to read past end of BoundedVec"
                    },
                    "17843811134343075018": {
                        "error_kind": "string",
                        "string": "Stack too deep"
                    },
                    "17879506016437779469": {
                        "error_kind": "fmtstring",
                        "length": 128,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "18194595712952743247": {
                        "error_kind": "fmtstring",
                        "length": 98,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    }
                }
            },
            "bytecode": "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",
            "debug_symbols": "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",
            "brillig_names": [
                "discover_new_messages",
                "debug_log_oracle_wrapper"
            ],
            "verification_key": "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"
        },
        {
            "name": "verify_private_authwit",
            "is_unconstrained": false,
            "custom_attributes": [
                "private",
                "noinitcheck",
                "view"
            ],
            "abi": {
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "kind": "struct",
                            "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
                            "fields": [
                                {
                                    "name": "call_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                        "fields": [
                                            {
                                                "name": "msg_sender",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "contract_address",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "function_selector",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "is_static_call",
                                                "type": {
                                                    "kind": "boolean"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "historical_header",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                        "fields": [
                                            {
                                                "name": "last_archive",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                    "fields": [
                                                        {
                                                            "name": "root",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "next_available_leaf_index",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content_commitment",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                    "fields": [
                                                        {
                                                            "name": "num_txs",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "blobs_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "in_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "out_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "state",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                    "fields": [
                                                        {
                                                            "name": "l1_to_l2_message_tree",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                "fields": [
                                                                    {
                                                                        "name": "root",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "next_available_leaf_index",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "partial",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                                "fields": [
                                                                    {
                                                                        "name": "note_hash_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "nullifier_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "public_data_tree",
                                                                        "type": {
                                                                            "kind": "struct",
                                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ]
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "global_variables",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                    "fields": [
                                                        {
                                                            "name": "chain_id",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "version",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "block_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "slot_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "timestamp",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 64
                                                            }
                                                        },
                                                        {
                                                            "name": "coinbase",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "fee_recipient",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "gas_fees",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "total_fees",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "total_mana_used",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "tx_context",
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                        "fields": [
                                            {
                                                "name": "chain_id",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "version",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "gas_settings",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                    "fields": [
                                                        {
                                                            "name": "gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "teardown_gas_limits",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "max_priority_fees_per_gas",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        }
                                                    ]
                                                }
                                            }
                                        ]
                                    }
                                },
                                {
                                    "name": "start_side_effect_counter",
                                    "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                    }
                                }
                            ]
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "inner_hash",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
                        "fields": [
                            {
                                "name": "call_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "function_selector",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "args_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "returns_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "min_revertible_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "is_fee_payer",
                                "type": {
                                    "kind": "boolean"
                                }
                            },
                            {
                                "name": "max_block_number",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                                    "fields": [
                                        {
                                            "name": "_opt",
                                            "type": {
                                                "kind": "struct",
                                                "path": "std::option::Option",
                                                "fields": [
                                                    {
                                                        "name": "_is_some",
                                                        "type": {
                                                            "kind": "boolean"
                                                        }
                                                    },
                                                    {
                                                        "name": "_value",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "note_hash_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifier_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "key_validation_requests_and_generators",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                                        "fields": [
                                            {
                                                "name": "request",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                                    "fields": [
                                                        {
                                                            "name": "pk_m",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                                                "fields": [
                                                                    {
                                                                        "name": "x",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "y",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "is_infinite",
                                                                        "type": {
                                                                            "kind": "boolean"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "sk_app",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "sk_app_generator",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "note_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "nullifiers",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "note_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 5,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                                        "fields": [
                                            {
                                                "name": "call_context",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "function_selector",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "args_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "returns_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "start_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "end_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                                        "fields": [
                                            {
                                                "name": "inner",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "kind": "struct",
                                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ]
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        },
                                                        {
                                                            "name": "calldata_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "public_teardown_call_request",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        },
                                        {
                                            "name": "calldata_hash",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "l2_to_l1_msgs",
                                "type": {
                                    "kind": "array",
                                    "length": 2,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                        "fields": [
                                            {
                                                "name": "recipient",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "content",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "private_logs",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                                        "fields": [
                                            {
                                                "name": "log",
                                                "type": {
                                                    "kind": "struct",
                                                    "path": "authwit::aztec::protocol_types::abis::log::Log",
                                                    "fields": [
                                                        {
                                                            "name": "fields",
                                                            "type": {
                                                                "kind": "array",
                                                                "length": 18,
                                                                "type": {
                                                                    "kind": "field"
                                                                }
                                                            }
                                                        }
                                                    ]
                                                }
                                            },
                                            {
                                                "name": "note_hash_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "contract_class_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 1,
                                    "type": {
                                        "kind": "struct",
                                        "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ]
                                    }
                                }
                            },
                            {
                                "name": "start_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "end_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "historical_header",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                                    "fields": [
                                        {
                                            "name": "last_archive",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                "fields": [
                                                    {
                                                        "name": "root",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "next_available_leaf_index",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "content_commitment",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                                                "fields": [
                                                    {
                                                        "name": "num_txs",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "blobs_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "in_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "out_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "state",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                                                "fields": [
                                                    {
                                                        "name": "l1_to_l2_message_tree",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                            "fields": [
                                                                {
                                                                    "name": "root",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "next_available_leaf_index",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "partial",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                                            "fields": [
                                                                {
                                                                    "name": "note_hash_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "nullifier_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                },
                                                                {
                                                                    "name": "public_data_tree",
                                                                    "type": {
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ]
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "global_variables",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                                                "fields": [
                                                    {
                                                        "name": "chain_id",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "version",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "block_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "slot_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "timestamp",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 64
                                                        }
                                                    },
                                                    {
                                                        "name": "coinbase",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "fee_recipient",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "gas_fees",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        },
                                        {
                                            "name": "total_fees",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "total_mana_used",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "name": "tx_context",
                                "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                                    "fields": [
                                        {
                                            "name": "chain_id",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "version",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "gas_settings",
                                            "type": {
                                                "kind": "struct",
                                                "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                                                "fields": [
                                                    {
                                                        "name": "gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "teardown_gas_limits",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    },
                                                    {
                                                        "name": "max_priority_fees_per_gas",
                                                        "type": {
                                                            "kind": "struct",
                                                            "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ]
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    },
                    "visibility": "databus"
                },
                "error_types": {
                    "19458536156181958": {
                        "error_kind": "string",
                        "string": "Function verify_private_authwit can only be called statically"
                    },
                    "576755928210959028": {
                        "error_kind": "string",
                        "string": "0 has a square root; you cannot claim it is not square"
                    },
                    "2709101749560550278": {
                        "error_kind": "string",
                        "string": "Cannot serialize point at infinity as bytes."
                    },
                    "2896122431943215824": {
                        "error_kind": "fmtstring",
                        "length": 144,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "2920182694213909827": {
                        "error_kind": "string",
                        "string": "attempt to subtract with overflow"
                    },
                    "3305101268118424981": {
                        "error_kind": "string",
                        "string": "Attempted to delete past the length of a CapsuleArray"
                    },
                    "3367683922240523006": {
                        "error_kind": "fmtstring",
                        "length": 58,
                        "item_types": [
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "5019202896831570965": {
                        "error_kind": "string",
                        "string": "attempt to add with overflow"
                    },
                    "5727012404371710682": {
                        "error_kind": "string",
                        "string": "push out of bounds"
                    },
                    "5870202753060865374": {
                        "error_kind": "fmtstring",
                        "length": 61,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "6336853191198150230": {
                        "error_kind": "fmtstring",
                        "length": 77,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "6485997221020871071": {
                        "error_kind": "string",
                        "string": "call to assert_max_bit_size"
                    },
                    "6753155520859132764": {
                        "error_kind": "string",
                        "string": "Failed to deliver note"
                    },
                    "7233212735005103307": {
                        "error_kind": "string",
                        "string": "attempt to multiply with overflow"
                    },
                    "8270195893599566439": {
                        "error_kind": "string",
                        "string": "Invalid public keys hint for address"
                    },
                    "8830323656616886390": {
                        "error_kind": "string",
                        "string": "Got a public log emitted by a different contract"
                    },
                    "12099279057757775880": {
                        "error_kind": "string",
                        "string": "DST_LEN too large for offset"
                    },
                    "12822839658937144934": {
                        "error_kind": "fmtstring",
                        "length": 75,
                        "item_types": []
                    },
                    "13649294680379557736": {
                        "error_kind": "string",
                        "string": "extend_from_bounded_vec out of bounds"
                    },
                    "14225679739041873922": {
                        "error_kind": "string",
                        "string": "Index out of bounds"
                    },
                    "14514982005979867414": {
                        "error_kind": "string",
                        "string": "attempt to bit-shift with overflow"
                    },
                    "14657895983200220173": {
                        "error_kind": "string",
                        "string": "Attempted to read past the length of a CapsuleArray"
                    },
                    "15366650908120444287": {
                        "error_kind": "fmtstring",
                        "length": 48,
                        "item_types": [
                            {
                                "kind": "field"
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    },
                    "16218014537381711836": {
                        "error_kind": "string",
                        "string": "Value does not fit in field"
                    },
                    "16446004518090376065": {
                        "error_kind": "string",
                        "string": "Input length must be a multiple of 32"
                    },
                    "16954218183513903507": {
                        "error_kind": "string",
                        "string": "Attempted to read past end of BoundedVec"
                    },
                    "17843811134343075018": {
                        "error_kind": "string",
                        "string": "Stack too deep"
                    },
                    "17879506016437779469": {
                        "error_kind": "fmtstring",
                        "length": 128,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        ]
                    },
                    "18194595712952743247": {
                        "error_kind": "fmtstring",
                        "length": 98,
                        "item_types": [
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            },
                            {
                                "kind": "field"
                            }
                        ]
                    }
                }
            },
            "bytecode": "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",
            "debug_symbols": "7b3bruu8cq37LvN6Xohk8bReJQiCnFYwgYkkyGEDG0HefXkMd0nuvyXTZi+RVWS7CcafKdrFr1oXq5Vk8n/+9E///A///S9/95d//b//9p9/+j9/8z9/+uu//ePf/9df/u1fb//1P38y9vf/7z///e//9dd//ud//f1//Nef/o/1FP/8p3/+13+6/TMY+79//tP//ctf//lP/8cs/n///Hy1pWW92ob96hgOLnZL9l8XOxPS64uNz56+rr79++Fym/JRJMaGNRJDfrvaLYef7oJbP5zM8u3qv/3zn4wDmjM0BDRnaDzQnKEJh2gomR2NK6AhY9b4yfj9K0L+/Q3x8m9IR99grPNrxswtecu37/g1LB8Oc8nYdZjL0fxxmF2OhvldHt6G0nyiyevs402Gj/M5EFNM69zdQzSU/vdvb//1D//xl7/+9S//8nffVpDlvowcryN5Wb/7poHwEGn8TcW6qlFUNcpXjQpVo2LVqFQ1KteMckvVKFM1qkobrkobrkobrkobrkobrkobrkobrkobVKUNqtIGVWmDqrRBVdqgKm1QlTaoShtUpQ2q0oav0oav0oav0oav0oav0oav0oav0oav0oav0oav0kao0kao0kao0kao0kao0kao0kao0kao0kao0kao0kas0kas0kas0kas0kas0kas0kas0kas0kas0kas0kaq0kaq0kaq0kaq0kY61IZbfNhG5biPuhnm36N81ahQNSpWjUpVo3LNqHyoDWeW1aM7a/O3UUdNj7B+h/nWfDF05P/T2sPw7iGn/p7TbBjiScvasbmpOBXi8SGuV/uQdrcfzD0gKy0gJy0gkhaQlxZQkBZQlBZQkhZQlhWQXRZpAQm7U9ul/Z060rrw+fjY+jVHrX5v1oXP+odW9OHFya9hpPiwSNLh04xby2t7huD3DyZ7dHHaS6pvl/4m6EDwhwQJBH9I0IPgDwkGEPwhwQiCPySYQPCHBDMI/oygWUDwhwQNCP6QIDzJTwnCk/yUIIHgDwnCk/yUIDzJTwnCk/yUIDzJTwnCk/yQoIUn+SlBeJKfEoQn+SlBeJKfEiQQ/CFBeJKfEoQn+SlBeJKfEoQn+SlBeJIfEnQ9PInZCabXUEza3mA12brCRxvKeb3aR/v40b/naiaaq51orm6iudJEc/UTzTVMNNc40VzTRHPN88yVJqqbaKK6iSaq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a5++Il/+FSePf1i/wlz/Ffb6r3DXfwVd/xX++q8I139FvP4rrv/rTtf/defr/7rz9X/d+fq/7nz9X3e+/q87X//Xna//687X/3Xnj/+678NyzTCzLHXDTN0wWzfM1Q2jumG+blioGxbrhqW6YXUqMXUqMXUqMXUqMXUqMXUqMXUqMXUqMXUqMXUqMXUqsXUqsXUqsXUqsXUqsXUqsXUqsXUqsXUqsXUqsXUqcXUqcXUqcXUqcXUqcXUqcXUqcXUqcXUqcXUqcXUqoTqVUJ1KqE4lVKcSqlMJ1amE6lRCdSqhOpVQnUp8nUp8nUp8nUp8nUp8nUp8nUp8nUp8nUp8nUp8nUpCnUpCnUpCnUpCnUpCnUpCnUpCnUpCnUpCnUpCnUpinUpinUpinUpinUpinUpinUpinUpinUpinUpinUpSnUpSnUpSnUpSnUpSnUpSnUpSnUpSnUpSnUpSnUpynUpynUpynUpynUpynUpynUpynUpynUrqeq+mrvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92rreq+2rvdq63qvtq73aut6r7au92pPeq95e3nv1gkzB8NOVBLjNizbb8OOdpxlOs/iFg7JCsfLCifICifKCifJCieLCuesx98rHCMrHCsrHFl35Szrrpxl3ZWzrLtylnVXzrLuylnUXdktou7Kbml9V355FNMtHissHicsHhIWjxcWTxAWz8f35vuwVDcsVw07foJ7e0C4buFxewznC9BMiG473TfEsG+sc7TTwc2FrpvI3G5BrvDZYVm2DbAWt/+YPMev+I3w+P2yJiB4557jt8rjd8rjJ+Xxe+XxB+XxR+XxJ+XxZ93xW+nrbyl+5euvVb7+WuXrr1W+/lrl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",
            "brillig_names": [
                "discover_new_messages",
                "store_in_execution_cache_oracle_wrapper"
            ],
            "verification_key": "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"
        },
        {
            "name": "public_dispatch",
            "is_unconstrained": true,
            "custom_attributes": [
                "public"
            ],
            "abi": {
                "parameters": [
                    {
                        "name": "selector",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": null,
                "error_types": {
                    "1752556835457866331": {
                        "error_kind": "string",
                        "string": "No public functions"
                    }
                }
            },
            "bytecode": "JwAABAEqAAABBRhSVSgKJhpbPAABAA==",
            "debug_symbols": "XYxLCoAwDAXvkrUn8Coi0k9aAqEpsRWk9O5+cCFdzhveNPBoa9woBdlhXhqwOFNI0k2tT2CVmCluw3wYJWMZPww1uZ8tZ8bhn1Uc+qr4lF7X134B",
            "brillig_names": [
                "public_dispatch"
            ]
        }
    ],
    "outputs": {
        "globals": {
            "notes": [
                {
                    "fields": [
                        {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        },
                        {
                            "kind": "string",
                            "value": "PublicKeyNote"
                        },
                        {
                            "fields": [
                                {
                                    "name": "x",
                                    "value": {
                                        "fields": [
                                            {
                                                "name": "index",
                                                "value": {
                                                    "kind": "integer",
                                                    "sign": false,
                                                    "value": "0000000000000000000000000000000000000000000000000000000000000000"
                                                }
                                            },
                                            {
                                                "name": "nullable",
                                                "value": {
                                                    "kind": "boolean",
                                                    "value": false
                                                }
                                            }
                                        ],
                                        "kind": "struct"
                                    }
                                },
                                {
                                    "name": "y",
                                    "value": {
                                        "fields": [
                                            {
                                                "name": "index",
                                                "value": {
                                                    "kind": "integer",
                                                    "sign": false,
                                                    "value": "0000000000000000000000000000000000000000000000000000000000000001"
                                                }
                                            },
                                            {
                                                "name": "nullable",
                                                "value": {
                                                    "kind": "boolean",
                                                    "value": false
                                                }
                                            }
                                        ],
                                        "kind": "struct"
                                    }
                                },
                                {
                                    "name": "owner",
                                    "value": {
                                        "fields": [
                                            {
                                                "name": "index",
                                                "value": {
                                                    "kind": "integer",
                                                    "sign": false,
                                                    "value": "0000000000000000000000000000000000000000000000000000000000000002"
                                                }
                                            },
                                            {
                                                "name": "nullable",
                                                "value": {
                                                    "kind": "boolean",
                                                    "value": false
                                                }
                                            }
                                        ],
                                        "kind": "struct"
                                    }
                                }
                            ],
                            "kind": "struct"
                        }
                    ],
                    "kind": "tuple"
                }
            ],
            "storage": [
                {
                    "fields": [
                        {
                            "name": "contract_name",
                            "value": {
                                "kind": "string",
                                "value": "ObsidionDeployerFPC"
                            }
                        },
                        {
                            "name": "fields",
                            "value": {
                                "fields": [
                                    {
                                        "name": "signing_public_key",
                                        "value": {
                                            "fields": [
                                                {
                                                    "name": "slot",
                                                    "value": {
                                                        "kind": "integer",
                                                        "sign": false,
                                                        "value": "0000000000000000000000000000000000000000000000000000000000000001"
                                                    }
                                                }
                                            ],
                                            "kind": "struct"
                                        }
                                    }
                                ],
                                "kind": "struct"
                            }
                        }
                    ],
                    "kind": "struct"
                }
            ]
        },
        "structs": {
            "functions": [
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "app_payload",
                                        "type": {
                                            "fields": [
                                                {
                                                    "name": "function_calls",
                                                    "type": {
                                                        "kind": "array",
                                                        "length": 4,
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "args_hash",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "function_selector",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "inner",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "target_address",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "inner",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "is_public",
                                                                    "type": {
                                                                        "kind": "boolean"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "is_static",
                                                                    "type": {
                                                                        "kind": "boolean"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::entrypoint::function_call::FunctionCall"
                                                        }
                                                    }
                                                },
                                                {
                                                    "name": "nonce",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                }
                                            ],
                                            "kind": "struct",
                                            "path": "authwit::entrypoint::app::AppPayload"
                                        }
                                    },
                                    {
                                        "name": "fee_payload",
                                        "type": {
                                            "fields": [
                                                {
                                                    "name": "function_calls",
                                                    "type": {
                                                        "kind": "array",
                                                        "length": 2,
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "args_hash",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "function_selector",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "inner",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "target_address",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "inner",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "is_public",
                                                                    "type": {
                                                                        "kind": "boolean"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "is_static",
                                                                    "type": {
                                                                        "kind": "boolean"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "authwit::entrypoint::function_call::FunctionCall"
                                                        }
                                                    }
                                                },
                                                {
                                                    "name": "nonce",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                },
                                                {
                                                    "name": "is_fee_payer",
                                                    "type": {
                                                        "kind": "boolean"
                                                    }
                                                }
                                            ],
                                            "kind": "struct",
                                            "path": "authwit::entrypoint::fee::FeePayload"
                                        }
                                    },
                                    {
                                        "name": "cancellable",
                                        "type": {
                                            "kind": "boolean"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "ObsidionDeployerFPC::entrypoint_parameters"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "ObsidionDeployerFPC::entrypoint_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "inner_hash",
                                        "type": {
                                            "kind": "field"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "ObsidionDeployerFPC::verify_private_authwit_parameters"
                            }
                        },
                        {
                            "name": "return_type",
                            "type": {
                                "kind": "field"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "ObsidionDeployerFPC::verify_private_authwit_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "max_fee",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 128
                                        }
                                    },
                                    {
                                        "name": "nonce",
                                        "type": {
                                            "kind": "field"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "ObsidionDeployerFPC::fee_entrypoint_private_parameters"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "ObsidionDeployerFPC::fee_entrypoint_private_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [],
                                "kind": "struct",
                                "path": "ObsidionDeployerFPC::get_accepted_asset_parameters"
                            }
                        },
                        {
                            "name": "return_type",
                            "type": {
                                "fields": [
                                    {
                                        "name": "inner",
                                        "type": {
                                            "kind": "field"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "ObsidionDeployerFPC::get_accepted_asset_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "max_fee",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 128
                                        }
                                    },
                                    {
                                        "name": "nonce",
                                        "type": {
                                            "kind": "field"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "ObsidionDeployerFPC::fee_entrypoint_public_parameters"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "ObsidionDeployerFPC::fee_entrypoint_public_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "signing_pub_key_x",
                                        "type": {
                                            "kind": "field"
                                        }
                                    },
                                    {
                                        "name": "signing_pub_key_y",
                                        "type": {
                                            "kind": "field"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "ObsidionDeployerFPC::constructor_parameters"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "ObsidionDeployerFPC::constructor_abi"
                }
            ]
        }
    },
    "file_map": {
        "102": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
            "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
        },
        "105": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
            "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
        },
        "107": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
            "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
        },
        "110": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
            "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
        },
        "111": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
            "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
        },
        "112": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
            "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
        },
        "114": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
            "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
        },
        "115": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
            "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
        },
        "116": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
            "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
        },
        "117": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
            "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
        },
        "12": {
            "path": "std/convert.nr",
            "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
        },
        "124": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
            "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
        },
        "125": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
            "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
        },
        "130": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
            "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
        },
        "132": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
            "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
        },
        "135": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
            "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
        },
        "138": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
            "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
        },
        "141": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/note/utils.nr",
            "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
        },
        "144": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
            "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
        },
        "145": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
            "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
        },
        "146": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
            "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
        },
        "147": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
            "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
        },
        "148": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
            "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
        },
        "149": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
            "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
        },
        "152": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr",
            "source": "use crate::utils::array;\nuse dep::protocol_types::{\n    abis::nullifier_leaf_preimage::NullifierLeafPreimage, constants::NULLIFIER_TREE_HEIGHT,\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 44;\n\npub struct NullifierMembershipWitness {\n    pub index: Field,\n    pub leaf_preimage: NullifierLeafPreimage,\n    pub path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let serialized_leaf_preimage = array::subarray(fields, 1);\n\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(serialized_leaf_preimage),\n            path: array::subarray(fields, 1 + serialized_leaf_preimage.len()),\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> NullifierMembershipWitness {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_low_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    get_low_nullifier_membership_witness_oracle(block_number, nullifier)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> NullifierMembershipWitness {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    get_nullifier_membership_witness_oracle(block_number, nullifier)\n}\n"
        },
        "154": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
            "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
        },
        "155": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
            "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
        },
        "156": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
            "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
        },
        "157": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
            "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
        },
        "159": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
            "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
        },
        "16": {
            "path": "std/embedded_curve_ops.nr",
            "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
        },
        "160": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
            "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
        },
        "161": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
            "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
        },
        "166": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
            "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
        },
        "17": {
            "path": "std/field/bn254.nr",
            "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
        },
        "18": {
            "path": "std/field/mod.nr",
            "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
        },
        "187": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
            "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
        },
        "188": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
            "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
        },
        "19": {
            "path": "std/hash/mod.nr",
            "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
        },
        "190": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
            "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
        },
        "191": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
            "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
        },
        "193": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
            "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
        },
        "194": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
            "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
        },
        "196": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/utils/field.nr",
            "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
        },
        "198": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/utils/point.nr",
            "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
        },
        "199": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/utils/random.nr",
            "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
        },
        "20": {
            "path": "std/hash/poseidon2.nr",
            "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
        },
        "226": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
            "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
        },
        "25": {
            "path": "std/meta/expr.nr",
            "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
        },
        "271": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
            "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
        },
        "274": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
            "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
        },
        "276": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
            "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
        },
        "281": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
            "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
        },
        "288": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
            "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
        },
        "289": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
            "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
        },
        "290": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
            "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
        },
        "303": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
            "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
        },
        "305": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
            "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
        },
        "306": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
            "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
        },
        "315": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
            "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
        },
        "345": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
            "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
        },
        "361": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
            "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
        },
        "362": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
            "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
        },
        "364": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
            "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
        },
        "370": {
            "path": "/Users/jack-sw/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
            "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
        },
        "371": {
            "path": "/Users/jack-sw/nargo/github.com/noir-lang/schnorr/v0.1.2/src/lib.nr",
            "source": "use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\nuse std::hash::{blake2s, pedersen_hash};\n\n// the multiples of BN_P that are still less than 2^254 split into (lo, hi)\nglobal BN_P_m: [(Field, Field); 6] = [\n    (0, 0),\n    (201385395114098847380338600778089168199, 64323764613183177041862057485226039389),\n    (62488423307259231297302594124410124942, 128647529226366354083724114970452078779),\n    (263873818421358078677641194902499293141, 192971293839549531125586172455678118168),\n    (124976846614518462594605188248820249884, 257295058452732708167448229940904157558),\n    (326362241728617309974943789026909418083, 321618823065915885209310287426130196947),\n];\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\npub fn verify_signature<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    signature: [u8; 64],\n    message: [u8; N],\n) -> bool {\n    //scalar lo/hi from bytes\n    let sig_s = scalar_from_bytes(signature, 0);\n    let sig_e = scalar_from_bytes(signature, 32);\n    // pub_key is on Grumpkin curve\n    let mut is_ok = (public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17)\n        & (!public_key.is_infinite);\n\n    if ((sig_s.lo != 0) | (sig_s.hi != 0)) & ((sig_e.lo != 0) | (sig_e.hi != 0)) {\n        let (r_is_infinite, result) =\n            calculate_signature_challenge(public_key, sig_s, sig_e, message);\n\n        is_ok &= !r_is_infinite;\n        for i in 0..32 {\n            is_ok &= result[i] == signature[32 + i];\n        }\n    } else {\n        is_ok = false;\n    }\n    is_ok\n}\n\npub fn assert_valid_signature<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    signature: [u8; 64],\n    message: [u8; N],\n) {\n    //scalar lo/hi from bytes\n    let sig_s = scalar_from_bytes(signature, 0);\n    let sig_e = scalar_from_bytes(signature, 32);\n\n    // assert pub_key is on Grumpkin curve\n    assert(public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17);\n    assert(public_key.is_infinite == false);\n    // assert signature is not null\n    assert((sig_s.lo != 0) | (sig_s.hi != 0));\n    assert((sig_e.lo != 0) | (sig_e.hi != 0));\n\n    let (r_is_infinite, result) = calculate_signature_challenge(public_key, sig_s, sig_e, message);\n\n    assert(!r_is_infinite);\n    for i in 0..32 {\n        assert(result[i] == signature[32 + i]);\n    }\n}\n\nfn calculate_signature_challenge<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    sig_s: EmbeddedCurveScalar,\n    sig_e: EmbeddedCurveScalar,\n    message: [u8; N],\n) -> (bool, [u8; 32]) {\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    let reduced_sig_e = normalize_signature(sig_e);\n    let r = multi_scalar_mul([g1, public_key], [sig_s, reduced_sig_e]);\n    // compare the _hashes_ rather than field elements modulo r\n    let pedersen_hash = pedersen_hash([r.x, public_key.x, public_key.y]);\n    let pde: [u8; 32] = pedersen_hash.to_be_bytes();\n\n    let mut hash_input = [0; N + 32];\n    for i in 0..32 {\n        hash_input[i] = pde[i];\n    }\n    for i in 0..N {\n        hash_input[32 + i] = message[i];\n    }\n\n    let result = blake2s(hash_input);\n    (r.is_infinite, result)\n}\n\nunconstrained fn __gt(a: Field, b: Field) -> bool {\n    b.lt(a)\n}\n\n// gets the quotient of lo/hi when divided by BN254_Fq modulus\nunconstrained fn __get_quotient(hi: Field, lo: Field) -> Field {\n    let mut q: Field = 0;\n    let mut r_hi = hi;\n    let mut r_lo = lo;\n    let MODULUS = BN_P_m[1];\n\n    for _ in 1..6 {\n        // check if rhi, rlo is larger than BN_P\n        let borrow = r_lo.lt(MODULUS.0);\n\n        if borrow {\n            r_lo = r_lo + TWO_POW_128;\n            // rlo is always larger than BN_P lo now\n            r_hi = r_hi - 1;\n        }\n\n        let MODULUS_hi = MODULUS.1;\n\n        let gt_flag = !r_hi.lt(MODULUS_hi);\n\n        if gt_flag {\n            r_hi = r_hi - MODULUS.1;\n            r_lo = r_lo - MODULUS.0;\n            if TWO_POW_128.lt(r_lo) | TWO_POW_128.lt(r_hi) {\n                break;\n            }\n            q += 1;\n        }\n    }\n    q\n}\n\n// this method reduces the signature to the range [0, BN254_Fq_MODULUS)\nfn normalize_signature(sig_e: EmbeddedCurveScalar) -> EmbeddedCurveScalar {\n    let mut hi = sig_e.hi;\n    let mut lo = sig_e.lo;\n    // get the quotient\n    let q = unsafe { __get_quotient(hi, lo) };\n    let MODULUSmq = (BN_P_m[q].0, BN_P_m[q].1);\n    let MODULUS = BN_P_m[1];\n    // remove MODULUS * q from lo/hi\n    let borrow = unsafe { __gt(MODULUSmq.0, lo) };\n    // rlo, rhi is the signature without the multiple of MODULUS\n    let rlo = lo - MODULUSmq.0 + borrow as Field * TWO_POW_128;\n    let rhi = hi - borrow as Field - MODULUSmq.1;\n    // now we validate that rlo and rhi are positive\n    rlo.assert_max_bit_size::<128>();\n    rhi.assert_max_bit_size::<128>();\n    // validate that rlo, rhi is smaller than MODULUS\n    // if the lo is larger than the modulus lo we have to get a borrow\n    let borrow = unsafe { __gt(rlo, MODULUS.0) };\n    let rplo = MODULUS.0 - rlo + borrow as Field * TWO_POW_128;\n    let rphi = MODULUS.1 - rhi - borrow as Field;\n    // check that rplo and rphi are positive\n    rplo.assert_max_bit_size::<128>();\n    rphi.assert_max_bit_size::<128>();\n    EmbeddedCurveScalar::new(rlo, rhi)\n}\n\n//Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\nfn scalar_from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n    let mut v: Field = 1;\n    let mut lo: Field = 0;\n    let mut hi: Field = 0;\n    for i in 0..16 {\n        lo = lo + (bytes[offset + 31 - i] as Field) * v;\n        hi = hi + (bytes[offset + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    let sig_s = EmbeddedCurveScalar::new(lo, hi);\n    sig_s\n}\n\nmod test {\n    use super::normalize_signature;\n    use super::verify_signature;\n    use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar};\n\n    #[test]\n    fn test_zero_signature() {\n        let public_key: EmbeddedCurvePoint = EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860,\n            is_infinite: false,\n        };\n        let signature: [u8; 64] = [0; 64];\n        let message: [u8; _] = [2; 64]; // every message\n        let verified = verify_signature(public_key, signature, message);\n        assert(!verified);\n    }\n\n    #[test]\n    fn smoke_test() {\n        let message: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n        let pub_key_x: Field = 0x04b260954662e97f00cab9adb773a259097f7a274b83b113532bce27fa3fb96a;\n        let pub_key_y: Field = 0x2fd51571db6c08666b0edfbfbc57d432068bccd0110a39b166ab243da0037197;\n        let signature: [u8; 64] = [\n            1, 13, 119, 112, 212, 39, 233, 41, 84, 235, 255, 93, 245, 172, 186, 83, 157, 253, 76,\n            77, 33, 128, 178, 15, 214, 67, 105, 107, 177, 234, 77, 48, 27, 237, 155, 84, 39, 84,\n            247, 27, 22, 8, 176, 230, 24, 115, 145, 220, 254, 122, 135, 179, 171, 4, 214, 202, 64,\n            199, 19, 84, 239, 138, 124, 12,\n        ];\n\n        let pub_key = EmbeddedCurvePoint { x: pub_key_x, y: pub_key_y, is_infinite: false };\n        let valid_signature = verify_signature(pub_key, signature, message);\n        assert(valid_signature);\n        super::assert_valid_signature(pub_key, signature, message);\n    }\n\n    #[test]\n    fn test_normalize_signature() {\n        let sig_e = EmbeddedCurveScalar::new(\n            201385395114098847380338600778112493540,\n            64323764613183177041862057485226039389,\n        );\n        let normalized = normalize_signature(sig_e);\n        let expected = EmbeddedCurveScalar::new(23325341, 0);\n        assert(normalized == expected);\n    }\n\n    #[test]\n    fn test_normalize_signature_2() {\n        let sig_e = EmbeddedCurveScalar::new(\n            263873818421358078677641194902522618482,\n            192971293839549531125586172455678118168,\n        );\n        let normalized = normalize_signature(sig_e);\n        let expected = EmbeddedCurveScalar::new(23325341, 0);\n        assert(normalized == expected);\n    }\n\n}\n\nmod bench {\n    use super::{assert_valid_signature, verify_signature};\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\n\n    #[export]\n    pub fn bench_verify_signature(\n        public_key: EmbeddedCurvePoint,\n        signature: [u8; 64],\n        message: [u8; 32],\n    ) -> bool {\n        verify_signature(public_key, signature, message)\n    }\n\n    #[export]\n    pub fn bench_assert_valid_signature(\n        public_key: EmbeddedCurvePoint,\n        signature: [u8; 64],\n        message: [u8; 32],\n    ) {\n        assert_valid_signature(public_key, signature, message)\n    }\n}\n\n"
        },
        "42": {
            "path": "std/option.nr",
            "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
        },
        "43": {
            "path": "std/panic.nr",
            "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
        },
        "5": {
            "path": "std/cmp.nr",
            "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
        },
        "50": {
            "path": "/Users/jack-sw/codes/obsidion/obsidion-wallet/packages/aztec-contracts/contracts/obsidion_deployer_fpc/src/main.nr",
            "source": "mod public_key_note;\nuse dep::aztec::macros::aztec;\n\n// This is obsidion deployer contract that has a capability to sponsor any transaction\n// Basically FPC + Account contract\n\n#[aztec]\ncontract ObsidionDeployerFPC {\n    use dep::authwit::{\n        account::AccountActions,\n        auth::{compute_authwit_message_hash, compute_authwit_nullifier},\n        auth_witness::get_auth_witness,\n        entrypoint::{app::AppPayload, fee::FeePayload},\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::hash::compute_siloed_nullifier;\n    use dep::aztec::macros::{\n        functions::{initializer, noinitcheck, private, view, utility},\n        storage::storage,\n    };\n    use dep::aztec::oracle::get_nullifier_membership_witness::get_low_nullifier_membership_witness;\n    use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateImmutable};\n\n    use crate::public_key_note::PublicKeyNote;\n\n    #[storage]\n    struct Storage<Context> {\n        signing_public_key: PrivateImmutable<PublicKeyNote, Context>,\n    }\n\n    ///////////////////////////////////////\n    ///////  Account Contract Logic  //////\n    ///////////////////////////////////////\n\n    // Constructs the contract\n    #[private]\n    #[initializer]\n    fn constructor(signing_pub_key_x: Field, signing_pub_key_y: Field) {\n        let this = context.this_address();\n        let pub_key_note = PublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this);\n        storage.signing_public_key.initialize(pub_key_note).emit(encode_and_encrypt_note(\n            &mut context,\n            this,\n            this,\n        ));\n    }\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts file\n    // using noinitcheck is an optimization, it reduces gates by omitting a check that the contract has been initialized\n    #[private]\n    #[noinitcheck]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[noinitcheck]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // docs:start:is_valid_impl\n        // Load public key from storage\n        // let storage = Storage::init(context);\n        // let public_key = storage.signing_public_key.get_note();\n\n        // // Load auth witness\n        // // Safety: The witness is only used as a \"magical value\" that makes the signature verification below pass.\n        // // Hence it's safe.\n        // let witness: [Field; 64] = unsafe { get_auth_witness(outer_hash) };\n        // let mut signature: [u8; 64] = [0; 64];\n        // for i in 0..64 {\n        //     signature[i] = witness[i] as u8;\n        // }\n\n        // let pub_key = std::embedded_curve_ops::EmbeddedCurvePoint {\n        //     x: public_key.x,\n        //     y: public_key.y,\n        //     is_infinite: false,\n        // };\n        // // Verify signature of the payload bytes\n        // schnorr::verify_signature(pub_key, signature, outer_hash.to_be_bytes::<32>())\n        // docs:end:is_valid_impl\n\n        true\n    }\n\n    /**\n    * @notice Helper function to check validity of private authwitnesses\n    * @param consumer The address of the consumer of the message\n    * @param message_hash The message hash of the message to check the validity\n    * @return True if the message_hash can be consumed, false otherwise\n    */\n    #[utility]\n    unconstrained fn lookup_validity(consumer: AztecAddress, inner_hash: Field) -> pub bool {\n        let public_key = storage.signing_public_key.view_note();\n\n        let message_hash = compute_authwit_message_hash(\n            consumer,\n            context.chain_id(),\n            context.version(),\n            inner_hash,\n        );\n\n        let witness: [Field; 64] = get_auth_witness(message_hash);\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n        let pub_key = std::embedded_curve_ops::EmbeddedCurvePoint {\n            x: public_key.x,\n            y: public_key.y,\n            is_infinite: false,\n        };\n        let valid_in_private =\n            schnorr::verify_signature(pub_key, signature, message_hash.to_be_bytes::<32>());\n\n        // Compute the nullifier and check if it is spent\n        // This will BLINDLY TRUST the oracle, but the oracle is us, and\n        // it is not as part of execution of the contract, so we are good.\n        let nullifier = compute_authwit_nullifier(context.this_address(), inner_hash);\n        let siloed_nullifier = compute_siloed_nullifier(consumer, nullifier);\n        let lower_wit =\n            get_low_nullifier_membership_witness(context.block_number(), siloed_nullifier);\n        let is_spent = lower_wit.leaf_preimage.nullifier == siloed_nullifier;\n\n        !is_spent & valid_in_private\n    }\n    \n    ///////////////////////////////////////\n    ///////  FPC Contract Logic  //////\n    ///////////////////////////////////////\n\n    #[private]\n    fn fee_entrypoint_private(max_fee: u128, nonce: Field) {\n        context.set_as_fee_payer();\n    }\n\n    #[private]\n    fn fee_entrypoint_public(max_fee: u128, nonce: Field) {\n        context.set_as_fee_payer();\n    }\n\n    #[private]\n    fn get_accepted_asset() -> AztecAddress {\n        context.this_address()\n    }\n}\n"
        },
        "52": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/authwit/src/account.nr",
            "source": "use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::{\n        constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::Hash,\n    },\n};\n\nuse crate::auth::{compute_authwit_message_hash, IS_VALID_SELECTOR};\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\n\npub struct AccountActions<Context> {\n    context: Context,\n    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD,\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier =\n                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash,\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"
        },
        "53": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/authwit/src/auth.nr",
            "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
        },
        "54": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/authwit/src/auth_witness.nr",
            "source": "#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n *\n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\npub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"
        },
        "56": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr",
            "source": "use dep::aztec::{\n    prelude::PrivateContext,\n    protocol_types::{\n        constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n        hash::poseidon2_hash_with_separator,\n        traits::{Hash, Serialize},\n    },\n};\nuse std::meta::derive;\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\n#[derive(Serialize)]\npub struct AppPayload {\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n    pub nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage()\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    pub fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_calldata_hash(\n                        call.target_address,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_args_hash(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"
        },
        "57": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr",
            "source": "use crate::entrypoint::function_call::FunctionCall;\nuse dep::aztec::{\n    prelude::PrivateContext,\n    protocol_types::{\n        constants::GENERATOR_INDEX__FEE_PAYLOAD,\n        hash::poseidon2_hash_with_separator,\n        traits::{Hash, Serialize},\n    },\n};\nuse std::meta::derive;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\n#[derive(Serialize)]\npub struct FeePayload {\n    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n    nonce: Field,\n    is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage()\n    }\n\n    pub fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_calldata_hash(\n                        call.target_address,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_args_hash(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"
        },
        "6": {
            "path": "std/collections/bounded_vec.nr",
            "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
        },
        "61": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
            "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
        },
        "69": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
            "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
        },
        "72": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
            "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
        },
        "76": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/hash.nr",
            "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
        },
        "91": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
            "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
        },
        "92": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
            "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
        },
        "93": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
            "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
        },
        "97": {
            "path": "/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
            "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
        }
    }
}
